/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./demo/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./demo/audio.ts":
/*!***********************!*\
  !*** ./demo/audio.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BUFFER_SIZE = 512;\nclass Audio {\n    constructor() {\n        this.ctx = new AudioContext();\n        this.source = this.ctx.createBufferSource();\n        this.scriptNode = this.ctx.createScriptProcessor(BUFFER_SIZE, 0, 1);\n        this.buffer = [];\n    }\n    start() {\n        this.scriptNode.onaudioprocess = e => this.process(e);\n        this.source.connect(this.scriptNode);\n        this.scriptNode.connect(this.ctx.destination);\n        this.source.start();\n        setInterval(() => {\n            this.waitSample();\n        }, 1);\n    }\n    get sampleRate() {\n        return this.ctx.sampleRate;\n    }\n    onSample(volume) {\n        this.buffer.push(volume);\n    }\n    process(e) {\n        const outputData = e.outputBuffer.getChannelData(0);\n        this.waitSample();\n        for (let sample = 0; sample < outputData.length; sample++) {\n            outputData[sample] = this.buffer.shift();\n        }\n    }\n    waitSample() {\n        while (this.buffer.length < BUFFER_SIZE) {\n            this.emulator.clock();\n        }\n    }\n}\nexports.Audio = Audio;\n\n\n//# sourceURL=webpack:///./demo/audio.ts?");

/***/ }),

/***/ "./demo/cpu-register.ts":
/*!******************************!*\
  !*** ./demo/cpu-register.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sprintf_js_1 = __webpack_require__(/*! sprintf-js */ \"./node_modules/sprintf-js/src/sprintf.js\");\nclass CpuRegister {\n    constructor(emulator, element) {\n        this.emulator = emulator;\n        this.element = element;\n    }\n    start() {\n        this.interval = setInterval(() => {\n            this.refresh();\n        }, 100);\n    }\n    stop() {\n        clearInterval(this.interval);\n    }\n    refresh() {\n        const cpu = this.emulator.cpu;\n        const PC = cpu.registers.PC;\n        const SP = cpu.registers.SP;\n        const A = cpu.registers.A;\n        const X = cpu.registers.X;\n        const Y = cpu.registers.Y;\n        const P = cpu.registers.P;\n        const txt = sprintf_js_1.sprintf('PC:%04X SP:%02X A:%02X X:%02X Y:%02X P:%02X', PC, SP, A, X, Y, P);\n        this.element.innerHTML = `<code>${txt}</code>`;\n    }\n}\nexports.CpuRegister = CpuRegister;\n\n\n//# sourceURL=webpack:///./demo/cpu-register.ts?");

/***/ }),

/***/ "./demo/disasm.ts":
/*!************************!*\
  !*** ./demo/disasm.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst opcode_table_1 = __webpack_require__(/*! ../src/cpu/opcode-table */ \"./src/cpu/opcode-table.ts\");\nconst sprintf_js_1 = __webpack_require__(/*! sprintf-js */ \"./node_modules/sprintf-js/src/sprintf.js\");\nclass DisASM {\n    constructor(emulator, element) {\n        this.emulator = emulator;\n        this.element = element;\n        this.cpuBus = this.emulator.cpu.bus;\n    }\n    start() {\n        this.interval = setInterval(() => {\n            this.refresh();\n        }, 100);\n    }\n    stop() {\n        clearInterval(this.interval);\n    }\n    refresh() {\n        const cpu = this.emulator.cpu;\n        const disGen = this.disASM(cpu.registers.PC);\n        const instrList = Array(30).fill(0).map(() => disGen.next().value);\n        this.element.innerHTML = instrList.map(v => `<p><code>${v}</code></p>`).join('\\n');\n    }\n    *disASM(pc) {\n        for (let i = pc; i < 0xFFFF;) {\n            const opcode = this.cpuBus.readByte(i++);\n            const entry = opcode_table_1.default[opcode];\n            if (!entry) {\n                yield sprintf_js_1.sprintf('%04X: UNDEFINED', i - 1);\n                continue;\n            }\n            const data = new Uint8Array(entry.bytes - 1).fill(0).map(() => this.cpuBus.readByte(i++));\n            yield sprintf_js_1.sprintf('%04X: %s %s', i - entry.bytes, opcode_table_1.Instruction[entry.instruction], this.parseAddressingMode(i - entry.bytes, entry.addressingMode, data));\n        }\n    }\n    parseAddressingMode(pc, mode, data) {\n        switch (mode) {\n            case opcode_table_1.AddressingMode.ABSOLUTE:\n                return sprintf_js_1.sprintf('$%04X', data[1] << 8 | data[0]);\n            case opcode_table_1.AddressingMode.ABSOLUTE_X:\n                return sprintf_js_1.sprintf('$%04X, X', data[1] << 8 | data[0]);\n            case opcode_table_1.AddressingMode.ABSOLUTE_Y:\n                return sprintf_js_1.sprintf('$%04X, Y', data[1] << 8 | data[0]);\n            case opcode_table_1.AddressingMode.ACCUMULATOR:\n                return 'A';\n            case opcode_table_1.AddressingMode.IMMEDIATE:\n                return sprintf_js_1.sprintf('#$%02X', data[0]);\n            case opcode_table_1.AddressingMode.IMPLICIT:\n                return '';\n            case opcode_table_1.AddressingMode.INDIRECT:\n                return sprintf_js_1.sprintf('($%04X)', data[1] << 8 | data[0]);\n            case opcode_table_1.AddressingMode.INDIRECT_Y_INDEXED:\n                return sprintf_js_1.sprintf('($%02X), Y', data[0]);\n            case opcode_table_1.AddressingMode.X_INDEXED_INDIRECT:\n                return sprintf_js_1.sprintf('($%02X, X)', data[0]);\n            case opcode_table_1.AddressingMode.RELATIVE:\n                return sprintf_js_1.sprintf('$%04X', data[0] & 0x80 ? pc - (0x100 - data[0]) : pc + data[0]);\n            case opcode_table_1.AddressingMode.ZERO_PAGE:\n                return sprintf_js_1.sprintf('$%02X', data[0]);\n            case opcode_table_1.AddressingMode.ZERO_PAGE_X:\n                return sprintf_js_1.sprintf('$%02X, X', data[0]);\n            case opcode_table_1.AddressingMode.ZERO_PAGE_Y:\n                return sprintf_js_1.sprintf('$%02X, Y', data[0]);\n            default:\n                throw new Error('Invalid addressing mode');\n        }\n    }\n}\nexports.DisASM = DisASM;\n\n\n//# sourceURL=webpack:///./demo/disasm.ts?");

/***/ }),

/***/ "./demo/index.ts":
/*!***********************!*\
  !*** ./demo/index.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst screen_1 = __webpack_require__(/*! ./screen */ \"./demo/screen.ts\");\nconst disasm_1 = __webpack_require__(/*! ./disasm */ \"./demo/disasm.ts\");\nconst palette_1 = __webpack_require__(/*! ./palette */ \"./demo/palette.ts\");\nconst partten_table_1 = __webpack_require__(/*! ./partten-table */ \"./demo/partten-table.ts\");\nconst ppu_register_1 = __webpack_require__(/*! ./ppu-register */ \"./demo/ppu-register.ts\");\nconst name_table_1 = __webpack_require__(/*! ./name-table */ \"./demo/name-table.ts\");\nconst status_1 = __webpack_require__(/*! ./status */ \"./demo/status.ts\");\nconst controller_1 = __webpack_require__(/*! ../src/api/controller */ \"./src/api/controller.ts\");\nconst src_1 = __webpack_require__(/*! ../src */ \"./src/index.ts\");\nconst cpu_register_1 = __webpack_require__(/*! ./cpu-register */ \"./demo/cpu-register.ts\");\nconst audio_1 = __webpack_require__(/*! ./audio */ \"./demo/audio.ts\");\nconst input = document.getElementById('file-input');\ninput.addEventListener('change', () => {\n    input.disabled = true;\n    const reader = new FileReader();\n    const file = input.files[0];\n    let buffer = new Uint8Array(0);\n    reader.readAsArrayBuffer(file);\n    reader.onload = e => {\n        const data = new Uint8Array(e.target.result);\n        const tmp = new Uint8Array(buffer.length + data.length);\n        tmp.set(buffer);\n        tmp.set(data, buffer.length);\n        buffer = tmp;\n    };\n    reader.onloadend = () => {\n        try {\n            startGame(file.name, buffer);\n        }\n        catch (e) {\n            console.log(e);\n            alert(e.message);\n        }\n    };\n});\nfunction startGame(filename, nesData) {\n    const audio = new audio_1.Audio();\n    const screen = new screen_1.Screen(document.getElementById('screen'));\n    const emulator = new src_1.Emulator(nesData, {\n        sampleRate: audio.sampleRate,\n        onSample: volume => audio.onSample(volume),\n        onFrame: frame => screen.onFrame(frame),\n        sramLoad: (() => {\n            if (localStorage.getItem(filename)) {\n                return Uint8Array.from(JSON.parse(localStorage.getItem(filename)));\n            }\n        })(),\n    });\n    audio.emulator = emulator;\n    screen.emulator = emulator;\n    const status = new status_1.Status(emulator, document.getElementById('rom'));\n    const cpuRegister = new cpu_register_1.CpuRegister(emulator, document.getElementById('register'));\n    const ppuRegister = new ppu_register_1.PPURegister(emulator, document.getElementById('ppu-register'));\n    const disASM = new disasm_1.DisASM(emulator, document.getElementById('disasm'));\n    const backgroundPalette = new palette_1.Palette(emulator, document.getElementById('background-palette'), 0x3F00);\n    const spritePalette = new palette_1.Palette(emulator, document.getElementById('sprite-palette'), 0x3F10);\n    const parttenTable1 = new partten_table_1.ParttenTable(emulator, document.getElementById('partten-table1'), 0x0000);\n    const parttenTable2 = new partten_table_1.ParttenTable(emulator, document.getElementById('partten-table2'), 0x1000);\n    const nameTable = new name_table_1.NameTable(emulator, document.getElementById('name-table'));\n    status.start();\n    audio.start();\n    const debug = document.getElementById('debug-ctrl');\n    debug.addEventListener('change', e => {\n        const elements = document.getElementsByClassName('debug');\n        if (debug.checked) {\n            cpuRegister.start();\n            ppuRegister.start();\n            disASM.start();\n            backgroundPalette.start();\n            spritePalette.start();\n            parttenTable1.start();\n            parttenTable2.start();\n            nameTable.start();\n        }\n        else {\n            cpuRegister.stop();\n            ppuRegister.stop();\n            disASM.stop();\n            backgroundPalette.stop();\n            spritePalette.stop();\n            parttenTable1.stop();\n            parttenTable2.stop();\n            nameTable.stop();\n        }\n        for (let i = 0; i < elements.length; i++) {\n            const element = elements.item(i);\n            element.style.opacity = debug.checked ? '1' : '0';\n        }\n    });\n    const trim = document.getElementById('trim-border');\n    trim.addEventListener('change', e => {\n        screen.isTrimBorder = trim.checked;\n    });\n    document.addEventListener('keydown', keyboardHandle);\n    document.addEventListener('keyup', keyboardHandle);\n    function keyboardHandle(e) {\n        let button;\n        switch (e.code) {\n            case 'KeyW':\n                button = controller_1.StandardControllerButton.UP;\n                break;\n            case 'KeyS':\n                button = controller_1.StandardControllerButton.DOWN;\n                break;\n            case 'KeyA':\n                button = controller_1.StandardControllerButton.LEFT;\n                break;\n            case 'KeyD':\n                button = controller_1.StandardControllerButton.RIGHT;\n                break;\n            case 'Enter':\n                button = controller_1.StandardControllerButton.START;\n                break;\n            case 'ShiftRight':\n                button = controller_1.StandardControllerButton.SELECT;\n                break;\n            case 'KeyL':\n                button = controller_1.StandardControllerButton.A;\n                break;\n            case 'KeyK':\n                button = controller_1.StandardControllerButton.B;\n                break;\n        }\n        emulator.standardController1.updateButton(button, e.type === 'keydown');\n        emulator.standardController2.updateButton(button, e.type === 'keydown');\n        e.preventDefault();\n    }\n    setInterval(() => {\n        localStorage.setItem(filename, JSON.stringify(Array.from(emulator.sram)));\n    }, 3000);\n}\n\n\n//# sourceURL=webpack:///./demo/index.ts?");

/***/ }),

/***/ "./demo/name-table.ts":
/*!****************************!*\
  !*** ./demo/name-table.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst palettes_1 = __webpack_require__(/*! ../src/emulator/palettes */ \"./src/emulator/palettes.ts\");\nclass NameTable {\n    constructor(emulator, canvas, context = canvas.getContext('2d'), imageData = context.createImageData(8, 8)) {\n        this.emulator = emulator;\n        this.canvas = canvas;\n        this.context = context;\n        this.imageData = imageData;\n        this.AddressTable = [0x2000, 0x2400, 0x2800, 0x2C00];\n    }\n    start() {\n        this.interval = setInterval(() => {\n            this.refresh();\n        }, 300);\n    }\n    stop() {\n        clearInterval(this.interval);\n    }\n    refresh() {\n        const ppu = this.emulator.ppu;\n        const ppuBus = this.emulator.ppuBus;\n        for (let screen = 0; screen < 4; screen++) {\n            const baseAddress = this.AddressTable[screen];\n            for (let i = 0; i < 32 * 30; i++) {\n                const tile = ppuBus.readByte(baseAddress + i);\n                const coarseX = i & 0x1F;\n                const coarseY = i >> 5;\n                const attributeOffset = ((coarseY >> 2) << 3) | ((coarseX & 0x1F) >> 2);\n                const attributeTable = ppuBus.readByte(baseAddress + 0x3C0 + attributeOffset);\n                const isRight = !!(coarseX & 0x02);\n                const isBottom = !!(coarseY & 0x02);\n                const offset = (isBottom ? 0x02 : 0) | (isRight ? 0x01 : 0);\n                const at = attributeTable >> (offset << 1) & 0x03;\n                let imageDataOffset = 0;\n                for (let y = 0; y < 8; y++) {\n                    const tileDataL = ppuBus.readByte(ppu.controller.backgroundPatternTableAddress + (tile << 4) + y);\n                    const tileDataH = ppuBus.readByte(ppu.controller.backgroundPatternTableAddress + (tile << 4) + y + 8);\n                    for (let x = 0; x < 8; x++) {\n                        const bit0 = (tileDataL >> (7 - x)) & 0x01;\n                        const bit1 = (tileDataH >> (7 - x)) & 0x01;\n                        const index = bit1 << 1 | bit0 << 0 | at << 2;\n                        const color = ppuBus.readByte(0x3F00 + index);\n                        const rgb = palettes_1.getColor(color);\n                        this.imageData.data[imageDataOffset++] = rgb[0];\n                        this.imageData.data[imageDataOffset++] = rgb[1];\n                        this.imageData.data[imageDataOffset++] = rgb[2];\n                        this.imageData.data[imageDataOffset++] = 255;\n                    }\n                }\n                switch (screen) {\n                    case 0:\n                        this.context.putImageData(this.imageData, coarseX * 8, coarseY * 8);\n                        break;\n                    case 1:\n                        this.context.putImageData(this.imageData, coarseX * 8 + 256, coarseY * 8);\n                        break;\n                    case 2:\n                        this.context.putImageData(this.imageData, coarseX * 8, coarseY * 8 + 240);\n                        break;\n                    case 3:\n                        this.context.putImageData(this.imageData, coarseX * 8 + 256, coarseY * 8 + 240);\n                        break;\n                }\n            }\n        }\n    }\n}\nexports.NameTable = NameTable;\n\n\n//# sourceURL=webpack:///./demo/name-table.ts?");

/***/ }),

/***/ "./demo/palette.ts":
/*!*************************!*\
  !*** ./demo/palette.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst palettes_1 = __webpack_require__(/*! ../src/emulator/palettes */ \"./src/emulator/palettes.ts\");\nclass Palette {\n    constructor(emulator, canvas, ppuAddress, context = canvas.getContext('2d')) {\n        this.emulator = emulator;\n        this.canvas = canvas;\n        this.ppuAddress = ppuAddress;\n        this.context = context;\n    }\n    start() {\n        this.interval = setInterval(() => {\n            this.refresh();\n        }, 100);\n    }\n    stop() {\n        clearInterval(this.interval);\n    }\n    refresh() {\n        const ppuBus = this.emulator.ppuBus;\n        const paletteData = Array(16).fill(0).map((v, i) => ppuBus.readByte(this.ppuAddress + i));\n        const colors = paletteData.map(palettes_1.getColor);\n        colors.forEach((c, i) => {\n            this.context.fillStyle = `rgb(${c[0]}, ${c[1]}, ${c[2]})`;\n            this.context.fillRect(i * 10, 0, i * 10 + 10, 10);\n        });\n    }\n}\nexports.Palette = Palette;\n\n\n//# sourceURL=webpack:///./demo/palette.ts?");

/***/ }),

/***/ "./demo/partten-table.ts":
/*!*******************************!*\
  !*** ./demo/partten-table.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst palettes_1 = __webpack_require__(/*! ../src/emulator/palettes */ \"./src/emulator/palettes.ts\");\nclass ParttenTable {\n    constructor(emulator, canvas, ppuAddress, context = canvas.getContext('2d'), imageData = context.createImageData(8, 8)) {\n        this.emulator = emulator;\n        this.canvas = canvas;\n        this.ppuAddress = ppuAddress;\n        this.context = context;\n        this.imageData = imageData;\n    }\n    start() {\n        this.interval = setInterval(() => {\n            this.refresh();\n        }, 1000);\n    }\n    stop() {\n        clearInterval(this.interval);\n    }\n    refresh() {\n        const ppuBus = this.emulator.ppuBus;\n        const data = new Uint8Array(4096).map((v, i) => ppuBus.readByte(this.ppuAddress + i));\n        const tileColors = Array(256).fill(0).map((v, i) => {\n            const tileL = data.slice(i * 16, i * 16 + 8);\n            const tileH = data.slice(i * 16 + 8, i * 16 + 8 + 8);\n            const arr = new Uint8Array(8 * 8);\n            for (let y = 0; y < 8; y++) {\n                for (let x = 0; x < 8; x++) {\n                    const offset = (tileH[y] & (0x80 >> x) ? 0x02 : 0) | (tileL[y] & (0x80 >> x) ? 0x01 : 0);\n                    arr[y * 8 + x] = ppuBus.readByte(0x3F00 + offset);\n                }\n            }\n            return arr;\n        });\n        tileColors.forEach((colors, tileOffset) => {\n            colors.forEach((color, i) => {\n                const rgb = palettes_1.getColor(color);\n                this.imageData.data[i * 4] = rgb[0];\n                this.imageData.data[i * 4 + 1] = rgb[1];\n                this.imageData.data[i * 4 + 2] = rgb[2];\n                this.imageData.data[i * 4 + 3] = 255;\n            });\n            this.context.putImageData(this.imageData, tileOffset % 16 * 8, Math.floor(tileOffset / 16) * 8);\n        });\n    }\n}\nexports.ParttenTable = ParttenTable;\n\n\n//# sourceURL=webpack:///./demo/partten-table.ts?");

/***/ }),

/***/ "./demo/ppu-register.ts":
/*!******************************!*\
  !*** ./demo/ppu-register.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sprintf_js_1 = __webpack_require__(/*! sprintf-js */ \"./node_modules/sprintf-js/src/sprintf.js\");\nclass PPURegister {\n    constructor(emulator, element) {\n        this.emulator = emulator;\n        this.element = element;\n    }\n    start() {\n        this.interval = setInterval(() => {\n            this.refresh();\n        }, 100);\n    }\n    stop() {\n        clearInterval(this.interval);\n    }\n    refresh() {\n        const ppu = this.emulator.ppu;\n        const v = ppu.register.v;\n        const t = ppu.register.t;\n        const x = ppu.register.x;\n        const w = ppu.register.w;\n        const cycle = ppu.cycle;\n        const scanLine = ppu.scanLine;\n        const frame = ppu.frame;\n        const txt = sprintf_js_1.sprintf('v:%04X t:%04X x:%1X w:%1X scanLine: %03d cycle: %03d frame: %d', v, t, x, w, scanLine, cycle, frame);\n        this.element.innerHTML = `<code>${txt}</code>`;\n    }\n}\nexports.PPURegister = PPURegister;\n\n\n//# sourceURL=webpack:///./demo/ppu-register.ts?");

/***/ }),

/***/ "./demo/screen.ts":
/*!************************!*\
  !*** ./demo/screen.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Screen {\n    constructor(canvas, scaleFactor = 3, context = canvas.getContext('2d'), screenImgData = context.createImageData(256 * scaleFactor, 240 * scaleFactor)) {\n        this.canvas = canvas;\n        this.scaleFactor = scaleFactor;\n        this.context = context;\n        this.screenImgData = screenImgData;\n        this.isTrimBorder = true;\n        this.canvas.height = 240 * scaleFactor;\n        this.canvas.width = 256 * scaleFactor;\n    }\n    onFrame(frame) {\n        let ptr = 0;\n        for (let y = 0; y < 240; y++) {\n            if (this.isTrimBorder &&\n                (0 <= y && y <= 7 || 232 <= y && y <= 239)) {\n                continue;\n            }\n            for (let i = 0; i < this.scaleFactor; i++) {\n                for (let x = 0; x < 256; x++) {\n                    const offset = (y * 256 + x) * 3;\n                    for (let j = 0; j < this.scaleFactor; j++) {\n                        this.screenImgData.data[ptr++] = frame[offset];\n                        this.screenImgData.data[ptr++] = frame[offset + 1];\n                        this.screenImgData.data[ptr++] = frame[offset + 2];\n                        this.screenImgData.data[ptr++] = 255;\n                    }\n                }\n            }\n        }\n        this.context.putImageData(this.screenImgData, 0, 0);\n    }\n}\nexports.Screen = Screen;\n\n\n//# sourceURL=webpack:///./demo/screen.ts?");

/***/ }),

/***/ "./demo/status.ts":
/*!************************!*\
  !*** ./demo/status.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cartridge_1 = __webpack_require__(/*! ../src/api/cartridge */ \"./src/api/cartridge.ts\");\nconst sprintf_js_1 = __webpack_require__(/*! sprintf-js */ \"./node_modules/sprintf-js/src/sprintf.js\");\nclass Status {\n    constructor(emulator, element) {\n        this.emulator = emulator;\n        this.element = element;\n        this.lastFrame = 0;\n    }\n    start() {\n        this.interval = setInterval(() => {\n            this.refresh();\n        }, 1000);\n    }\n    stop() {\n        clearInterval(this.interval);\n    }\n    refresh() {\n        const frame = this.emulator.ppu.frame;\n        const cartridge = this.emulator.cartridge;\n        const txt = sprintf_js_1.sprintf('PRG:%dx16KB CHR:%dx8KB mapper#:%d mirror:%s battery-backed:%s trained:%s fps:%d', cartridge.info.prg, cartridge.info.chr, cartridge.info.mapper, cartridge_1.Mirror[cartridge.info.mirror], cartridge.info.hasBatteryBacked ? 'yes' : 'no', cartridge.info.isTrained ? 'yes' : 'no', frame - this.lastFrame);\n        this.element.innerHTML = `<code>${txt}</code>`;\n        this.lastFrame = frame;\n    }\n}\nexports.Status = Status;\n\n\n//# sourceURL=webpack:///./demo/status.ts?");

/***/ }),

/***/ "./node_modules/sprintf-js/src/sprintf.js":
/*!************************************************!*\
  !*** ./node_modules/sprintf-js/src/sprintf.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* global window, exports, define */\n\n!function() {\n    'use strict'\n\n    var re = {\n        not_string: /[^s]/,\n        not_bool: /[^t]/,\n        not_type: /[^T]/,\n        not_primitive: /[^v]/,\n        number: /[diefg]/,\n        numeric_arg: /[bcdiefguxX]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[+-]/\n    }\n\n    function sprintf(key) {\n        // `arguments` is not an array, but should be fine for this call\n        return sprintf_format(sprintf_parse(key), arguments)\n    }\n\n    function vsprintf(fmt, argv) {\n        return sprintf.apply(null, [fmt].concat(argv || []))\n    }\n\n    function sprintf_format(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign\n        for (i = 0; i < tree_length; i++) {\n            if (typeof parse_tree[i] === 'string') {\n                output += parse_tree[i]\n            }\n            else if (typeof parse_tree[i] === 'object') {\n                ph = parse_tree[i] // convenience purposes only\n                if (ph.keys) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < ph.keys.length; k++) {\n                        if (arg == undefined) {\n                            throw new Error(sprintf('[sprintf] Cannot access property \"%s\" of undefined value \"%s\"', ph.keys[k], ph.keys[k-1]))\n                        }\n                        arg = arg[ph.keys[k]]\n                    }\n                }\n                else if (ph.param_no) { // positional argument (explicit)\n                    arg = argv[ph.param_no]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {\n                    arg = arg()\n                }\n\n                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {\n                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\n                }\n\n                if (re.number.test(ph.type)) {\n                    is_positive = arg >= 0\n                }\n\n                switch (ph.type) {\n                    case 'b':\n                        arg = parseInt(arg, 10).toString(2)\n                        break\n                    case 'c':\n                        arg = String.fromCharCode(parseInt(arg, 10))\n                        break\n                    case 'd':\n                    case 'i':\n                        arg = parseInt(arg, 10)\n                        break\n                    case 'j':\n                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)\n                        break\n                    case 'e':\n                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()\n                        break\n                    case 'f':\n                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)\n                        break\n                    case 'g':\n                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)\n                        break\n                    case 'o':\n                        arg = (parseInt(arg, 10) >>> 0).toString(8)\n                        break\n                    case 's':\n                        arg = String(arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 't':\n                        arg = String(!!arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'T':\n                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'u':\n                        arg = parseInt(arg, 10) >>> 0\n                        break\n                    case 'v':\n                        arg = arg.valueOf()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'x':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16)\n                        break\n                    case 'X':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()\n                        break\n                }\n                if (re.json.test(ph.type)) {\n                    output += arg\n                }\n                else {\n                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {\n                        sign = is_positive ? '+' : '-'\n                        arg = arg.toString().replace(re.sign, '')\n                    }\n                    else {\n                        sign = ''\n                    }\n                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '\n                    pad_length = ph.width - (sign + arg).length\n                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\n                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output\n    }\n\n    var sprintf_cache = Object.create(null)\n\n    function sprintf_parse(fmt) {\n        if (sprintf_cache[fmt]) {\n            return sprintf_cache[fmt]\n        }\n\n        var _fmt = fmt, match, parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree.push(match[0])\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree.push('%')\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list.push(field_match[1])\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key')\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\n                }\n\n                parse_tree.push(\n                    {\n                        placeholder: match[0],\n                        param_no:    match[1],\n                        keys:        match[2],\n                        sign:        match[3],\n                        pad_char:    match[4],\n                        align:       match[5],\n                        width:       match[6],\n                        precision:   match[7],\n                        type:        match[8]\n                    }\n                )\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder')\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return sprintf_cache[fmt] = parse_tree\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    /* eslint-disable quote-props */\n    if (true) {\n        exports['sprintf'] = sprintf\n        exports['vsprintf'] = vsprintf\n    }\n    if (typeof window !== 'undefined') {\n        window['sprintf'] = sprintf\n        window['vsprintf'] = vsprintf\n\n        if (true) {\n            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n                return {\n                    'sprintf': sprintf,\n                    'vsprintf': vsprintf\n                }\n            }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n        }\n    }\n    /* eslint-enable quote-props */\n}(); // eslint-disable-line\n\n\n//# sourceURL=webpack:///./node_modules/sprintf-js/src/sprintf.js?");

/***/ }),

/***/ "./src/api/cartridge.ts":
/*!******************************!*\
  !*** ./src/api/cartridge.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Mirror;\n(function (Mirror) {\n    Mirror[Mirror[\"HORIZONTAL\"] = 0] = \"HORIZONTAL\";\n    Mirror[Mirror[\"VERTICAL\"] = 1] = \"VERTICAL\";\n    Mirror[Mirror[\"FOUR_SCREEN\"] = 2] = \"FOUR_SCREEN\";\n    Mirror[Mirror[\"SINGLE_SCREEN_LOWER_BANK\"] = 3] = \"SINGLE_SCREEN_LOWER_BANK\";\n    Mirror[Mirror[\"SINGLE_SCREEN_UPPER_BANK\"] = 4] = \"SINGLE_SCREEN_UPPER_BANK\";\n})(Mirror = exports.Mirror || (exports.Mirror = {}));\n\n\n//# sourceURL=webpack:///./src/api/cartridge.ts?");

/***/ }),

/***/ "./src/api/controller.ts":
/*!*******************************!*\
  !*** ./src/api/controller.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar StandardControllerButton;\n(function (StandardControllerButton) {\n    StandardControllerButton[StandardControllerButton[\"A\"] = 128] = \"A\";\n    StandardControllerButton[StandardControllerButton[\"B\"] = 64] = \"B\";\n    StandardControllerButton[StandardControllerButton[\"SELECT\"] = 32] = \"SELECT\";\n    StandardControllerButton[StandardControllerButton[\"START\"] = 16] = \"START\";\n    StandardControllerButton[StandardControllerButton[\"UP\"] = 8] = \"UP\";\n    StandardControllerButton[StandardControllerButton[\"DOWN\"] = 4] = \"DOWN\";\n    StandardControllerButton[StandardControllerButton[\"LEFT\"] = 2] = \"LEFT\";\n    StandardControllerButton[StandardControllerButton[\"RIGHT\"] = 1] = \"RIGHT\";\n})(StandardControllerButton = exports.StandardControllerButton || (exports.StandardControllerButton = {}));\n\n\n//# sourceURL=webpack:///./src/api/controller.ts?");

/***/ }),

/***/ "./src/api/cpu.ts":
/*!************************!*\
  !*** ./src/api/cpu.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Flags;\n(function (Flags) {\n    Flags[Flags[\"C\"] = 1] = \"C\";\n    Flags[Flags[\"Z\"] = 2] = \"Z\";\n    Flags[Flags[\"I\"] = 4] = \"I\";\n    Flags[Flags[\"D\"] = 8] = \"D\";\n    Flags[Flags[\"B\"] = 16] = \"B\";\n    Flags[Flags[\"U\"] = 32] = \"U\";\n    Flags[Flags[\"V\"] = 64] = \"V\";\n    Flags[Flags[\"N\"] = 128] = \"N\";\n})(Flags = exports.Flags || (exports.Flags = {}));\n\n\n//# sourceURL=webpack:///./src/api/cpu.ts?");

/***/ }),

/***/ "./src/api/ppu.ts":
/*!************************!*\
  !*** ./src/api/ppu.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SpriteSize;\n(function (SpriteSize) {\n    SpriteSize[SpriteSize[\"SIZE_8X8\"] = 8] = \"SIZE_8X8\";\n    SpriteSize[SpriteSize[\"SIZE_8X16\"] = 16] = \"SIZE_8X16\";\n})(SpriteSize = exports.SpriteSize || (exports.SpriteSize = {}));\n\n\n//# sourceURL=webpack:///./src/api/ppu.ts?");

/***/ }),

/***/ "./src/apu/apu.ts":
/*!************************!*\
  !*** ./src/apu/apu.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst pulse_1 = __webpack_require__(/*! ./pulse */ \"./src/apu/pulse.ts\");\nconst triangle_1 = __webpack_require__(/*! ./triangle */ \"./src/apu/triangle.ts\");\nconst noise_1 = __webpack_require__(/*! ./noise */ \"./src/apu/noise.ts\");\nconst dmc_1 = __webpack_require__(/*! ./dmc */ \"./src/apu/dmc.ts\");\nclass APU {\n    constructor(sampleRate = 48000, onSample) {\n        this.sampleRate = sampleRate;\n        this.onSample = onSample;\n        this.pulse1 = new pulse_1.Pulse(1);\n        this.pulse2 = new pulse_1.Pulse(2);\n        this.triangle = new triangle_1.Triangle();\n        this.noise = new noise_1.Noise();\n        this.dmc = new dmc_1.Dmc();\n        this.frameInterruptFlag = false;\n        this.mode = 0;\n        this.isIRQEnabled = true;\n        this.clocks = 0;\n        this.sampleCounter = 0;\n        this.frameCounter = 0;\n    }\n    set cpuBus(cpuBus) {\n        this.dmc.cpuBus = cpuBus;\n    }\n    set interrupt(interrupt) {\n        this.interruptLine = interrupt;\n        this.dmc.interrupt = interrupt;\n    }\n    clock() {\n        this.clocks++;\n        if (this.clocks & 0x01) {\n            this.pulse1.clock();\n            this.pulse2.clock();\n            this.noise.clock();\n        }\n        this.dmc.clock();\n        this.triangle.clock();\n        const count = Math.floor(this.clocks / (1789773 / this.sampleRate));\n        if (count !== this.sampleCounter) {\n            this.sampleCounter = count;\n            this.sampleOutput();\n        }\n        const frameCount = Math.floor(this.clocks / (1789773 / 240));\n        if (frameCount !== this.frameCounter) {\n            this.frameCounter = frameCount;\n            this.processFrameCounter();\n        }\n    }\n    read(address) {\n        if (address === 0x4015) {\n            const data = (this.pulse1.lengthCounter > 0 ? 0x01 : 0) |\n                (this.pulse2.lengthCounter > 0 ? 0x02 : 0) |\n                (this.triangle.lengthCounter > 0 ? 0x04 : 0) |\n                (this.noise.lengthCounter > 0 ? 0x08 : 0) |\n                (this.dmc.bytesRemainingCounter > 0 ? 0x10 : 0) |\n                (this.frameInterruptFlag ? 0x40 : 0) |\n                (this.dmc.interruptFlag ? 0x80 : 0);\n            this.frameInterruptFlag = false;\n            return data;\n        }\n        else {\n            return 0;\n        }\n    }\n    write(address, data) {\n        switch (address) {\n            case 0x4000:\n            case 0x4001:\n            case 0x4002:\n            case 0x4003:\n                this.pulse1.write(address - 0x4000, data);\n                break;\n            case 0x4004:\n            case 0x4005:\n            case 0x4006:\n            case 0x4007:\n                this.pulse2.write(address - 0x4004, data);\n                break;\n            case 0x4008:\n            case 0x4009:\n            case 0x400A:\n            case 0x400B:\n                this.triangle.write(address - 0x4008, data);\n                break;\n            case 0x400C:\n            case 0x400D:\n            case 0x400E:\n            case 0x400F:\n                this.noise.write(address - 0x400C, data);\n                break;\n            case 0x4010:\n            case 0x4011:\n            case 0x4012:\n            case 0x4013:\n                this.dmc.write(address - 0x4010, data);\n                break;\n            case 0x4015:\n                this.pulse1.isEnabled = !!(data & 0x01);\n                this.pulse2.isEnabled = !!(data & 0x02);\n                this.triangle.isEnabled = !!(data & 0x04);\n                this.noise.isEnabled = !!(data & 0x08);\n                this.dmc.isEnabled = !!(data & 0x10);\n                this.dmc.interruptFlag = false;\n                break;\n            case 0x4017:\n                this.frameCounter = 0;\n                this.mode = data >> 7;\n                this.isIRQEnabled = !(data & 0x40);\n        }\n    }\n    sampleOutput() {\n        const pulseOut = 0.00952 * (this.pulse1.volume + this.pulse2.volume);\n        const tndOut = 0.00851 * this.triangle.volume + 0.00794 * this.noise.volume + 0.00335 * this.dmc.volume;\n        this.onSample(pulseOut + tndOut);\n    }\n    processFrameCounter() {\n        if (this.mode === 0) {\n            switch (this.frameCounter % 4) {\n                case 0:\n                    this.processEnvelopeAndLinearCounter();\n                    break;\n                case 1:\n                    this.processLengthCounterAndSweep();\n                    this.processEnvelopeAndLinearCounter();\n                    break;\n                case 2:\n                    this.processEnvelopeAndLinearCounter();\n                    break;\n                case 3:\n                    this.triggerIRQ();\n                    this.processLengthCounterAndSweep();\n                    this.processEnvelopeAndLinearCounter();\n                    break;\n            }\n        }\n        else {\n            switch (this.frameCounter % 5) {\n                case 0:\n                    this.processEnvelopeAndLinearCounter();\n                    break;\n                case 1:\n                    this.processLengthCounterAndSweep();\n                    this.processEnvelopeAndLinearCounter();\n                    break;\n                case 2:\n                    this.processEnvelopeAndLinearCounter();\n                    break;\n                case 3:\n                    break;\n                case 4:\n                    this.processLengthCounterAndSweep();\n                    this.processEnvelopeAndLinearCounter();\n                    break;\n            }\n        }\n    }\n    processEnvelopeAndLinearCounter() {\n        this.pulse1.processEnvelope();\n        this.pulse2.processEnvelope();\n        this.noise.processEnvelope();\n        this.triangle.processLinearCounter();\n    }\n    processLengthCounterAndSweep() {\n        this.pulse1.processLengthCounter();\n        this.pulse2.processLengthCounter();\n        this.triangle.processLengthCounter();\n        this.noise.processLengthCounter();\n        this.pulse1.processSweep();\n        this.pulse2.processSweep();\n    }\n    triggerIRQ() {\n        if (!this.isIRQEnabled) {\n            return;\n        }\n        this.frameInterruptFlag = true;\n        this.interruptLine.irq();\n    }\n}\nexports.APU = APU;\n\n\n//# sourceURL=webpack:///./src/apu/apu.ts?");

/***/ }),

/***/ "./src/apu/dmc.ts":
/*!************************!*\
  !*** ./src/apu/dmc.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst table_1 = __webpack_require__(/*! ./table */ \"./src/apu/table.ts\");\nclass Dmc {\n    constructor() {\n        this.volume = 0;\n        this.isEnabled = false;\n        this.bytesRemainingCounter = 0;\n        this.interruptFlag = false;\n        this.isMuted = true;\n        this.isIrqEnabled = false;\n        this.isLoopEnabled = false;\n        this.frequency = 0;\n        this.loadCounter = 0;\n        this.sampleAddress = 0;\n        this.sampleLength = 0;\n        this.clocks = 0;\n        this.sampleBuffer = 0;\n        this.addressCounter = 0;\n        this.bitsRemainingCounter = 0;\n    }\n    clock() {\n        if (!this.isEnabled) {\n            return;\n        }\n        if (this.clocks % (table_1.DMC_TABLE[this.frequency] + 1) === 0) {\n            this.outputUnit();\n        }\n        this.clocks++;\n    }\n    write(offset, data) {\n        switch (offset) {\n            case 0:\n                this.isIrqEnabled = !!(data & 0x80);\n                this.isLoopEnabled = !!(data & 0x40);\n                this.frequency = data & 0x0F;\n                this.clocks = 0;\n                if (!this.isIrqEnabled) {\n                    this.interruptFlag = false;\n                }\n                break;\n            case 1:\n                this.loadCounter = data & 0x7F;\n                this.restartSample();\n                break;\n            case 2:\n                this.sampleAddress = 0xC000 + data * 64;\n                this.restartSample();\n                break;\n            case 3:\n                this.sampleLength = data * 16 + 1;\n                this.restartSample();\n                break;\n        }\n    }\n    restartSample() {\n        this.addressCounter = this.sampleAddress;\n        this.bytesRemainingCounter = this.sampleLength;\n        this.isMuted = false;\n        this.volume = this.loadCounter;\n    }\n    memoryReader() {\n        if (this.bytesRemainingCounter <= 0 || this.bitsRemainingCounter > 0) {\n            return;\n        }\n        this.sampleBuffer = this.cpuBus.readByte(this.addressCounter);\n        this.addressCounter = this.addressCounter >= 0xFFFF ? 0x8000 : this.addressCounter + 1;\n        this.bytesRemainingCounter--;\n        if (this.bytesRemainingCounter <= 0) {\n            if (this.isLoopEnabled) {\n                this.restartSample();\n            }\n            else {\n                this.isMuted = true;\n                if (this.isIrqEnabled) {\n                    this.interruptFlag = true;\n                    this.interrupt.irq();\n                }\n            }\n        }\n    }\n    outputUnit() {\n        if (this.bitsRemainingCounter <= 0) {\n            if (this.isMuted) {\n                return;\n            }\n            this.memoryReader();\n            this.bitsRemainingCounter = 8;\n        }\n        if (this.sampleBuffer & 0x01) {\n            this.volume = this.volume > 125 ? 127 : this.volume + 2;\n        }\n        else {\n            this.volume = this.volume < 2 ? 0 : this.volume - 2;\n        }\n        this.sampleBuffer >>= 1;\n        this.bitsRemainingCounter--;\n    }\n}\nexports.Dmc = Dmc;\n\n\n//# sourceURL=webpack:///./src/apu/dmc.ts?");

/***/ }),

/***/ "./src/apu/noise.ts":
/*!**************************!*\
  !*** ./src/apu/noise.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst table_1 = __webpack_require__(/*! ./table */ \"./src/apu/table.ts\");\nclass Noise {\n    constructor() {\n        this.volume = 0;\n        this.isEnabled = false;\n        this.lengthCounter = 0;\n        this.isLengthCounterHalt = false;\n        this.isConstantVolume = false;\n        this.envelopeValue = 0;\n        this.envelopeVolume = 0;\n        this.envelopeCounter = 0;\n        this.isLoopNoise = false;\n        this.noisePeriod = 0;\n        this.internalTimer = 0;\n    }\n    clock() {\n        if (!this.isEnabled) {\n            return;\n        }\n        if (this.internalTimer === 0) {\n            this.internalTimer = this.noisePeriod;\n            this.step();\n        }\n        else {\n            this.internalTimer--;\n        }\n    }\n    processEnvelope() {\n        if (this.isConstantVolume) {\n            return;\n        }\n        if (this.envelopeCounter % (this.envelopeValue + 1) === 0) {\n            if (this.envelopeVolume === 0) {\n                this.envelopeVolume = this.isLengthCounterHalt ? 15 : 0;\n            }\n            else {\n                this.envelopeVolume--;\n            }\n        }\n        this.envelopeCounter++;\n    }\n    processLinearCounter() {\n    }\n    processLengthCounter() {\n        if (!this.isLengthCounterHalt && this.lengthCounter > 0) {\n            this.lengthCounter--;\n        }\n    }\n    processSweep() {\n    }\n    write(offset, data) {\n        switch (offset) {\n            case 0:\n                this.isLengthCounterHalt = !!(data & 0x20);\n                this.isConstantVolume = !!(data & 0x10);\n                this.envelopeValue = data & 0x0F;\n                this.envelopeVolume = 15;\n                this.envelopeCounter = 0;\n                break;\n            case 1:\n                break;\n            case 2:\n                this.isLoopNoise = !!(data & 0x80);\n                this.noisePeriod = table_1.NOISE_PEROID_TABLE[data & 0x0F];\n                this.internalTimer = 0;\n                break;\n            case 3:\n                this.lengthCounter = table_1.LENGTH_TABLE[data >> 3];\n                break;\n        }\n    }\n    step() {\n        if (!this.isEnabled || this.lengthCounter === 0) {\n            this.volume = 0;\n        }\n        else if (this.isConstantVolume) {\n            this.volume = Math.floor(Math.random() * this.envelopeValue);\n        }\n        else {\n            this.volume = Math.floor(Math.random() * this.envelopeVolume);\n        }\n    }\n}\nexports.Noise = Noise;\n\n\n//# sourceURL=webpack:///./src/apu/noise.ts?");

/***/ }),

/***/ "./src/apu/pulse.ts":
/*!**************************!*\
  !*** ./src/apu/pulse.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst table_1 = __webpack_require__(/*! ./table */ \"./src/apu/table.ts\");\nclass Pulse {\n    constructor(channel) {\n        this.channel = channel;\n        this.volume = 0;\n        this.isEnabled = false;\n        this.lengthCounter = 0;\n        this.duty = 0;\n        this.isEnvelopeLoop = false;\n        this.isConstantVolume = false;\n        this.envelopeValue = 0;\n        this.envelopeVolume = 0;\n        this.envelopeCounter = 0;\n        this.isSweepEnabled = false;\n        this.sweepPeriod = 0;\n        this.isSweepNegated = false;\n        this.sweepShift = 0;\n        this.sweepCounter = 0;\n        this.timer = 0;\n        this.internalTimer = 0;\n        this.counter = 0;\n    }\n    clock() {\n        if (!this.isEnabled) {\n            return;\n        }\n        if (this.internalTimer === 0) {\n            this.internalTimer = this.timer;\n            this.step();\n        }\n        else {\n            this.internalTimer--;\n        }\n    }\n    processEnvelope() {\n        if (this.isConstantVolume) {\n            return;\n        }\n        if (this.envelopeCounter % (this.envelopeValue + 1) === 0) {\n            if (this.envelopeVolume === 0) {\n                this.envelopeVolume = this.isEnvelopeLoop ? 15 : 0;\n            }\n            else {\n                this.envelopeVolume--;\n            }\n        }\n        this.envelopeCounter++;\n    }\n    processLinearCounter() {\n    }\n    processLengthCounter() {\n        if (!this.isEnvelopeLoop && this.lengthCounter > 0) {\n            this.lengthCounter--;\n        }\n    }\n    processSweep() {\n        if (!this.isSweepEnabled) {\n            return;\n        }\n        if (this.sweepCounter % (this.sweepPeriod + 1) === 0) {\n            const changeAmount = this.isSweepNegated ? -(this.timer >> this.sweepShift) : this.timer >> this.sweepShift;\n            this.timer += changeAmount;\n            if (this.channel === 1 && changeAmount <= 0) {\n                this.timer--;\n            }\n        }\n        this.sweepCounter++;\n    }\n    write(offset, data) {\n        switch (offset) {\n            case 0:\n                this.duty = data >> 6;\n                this.isEnvelopeLoop = !!(data & 0x20);\n                this.isConstantVolume = !!(data & 0x10);\n                this.envelopeValue = data & 0x0F;\n                this.envelopeVolume = 15;\n                this.envelopeCounter = 0;\n                break;\n            case 1:\n                this.isSweepEnabled = !!(data & 0x80);\n                this.sweepPeriod = data >> 4 & 0x07;\n                this.isSweepNegated = !!(data & 0x08);\n                this.sweepShift = data & 0x07;\n                this.sweepCounter = 0;\n                break;\n            case 2:\n                this.timer = this.timer & 0xFF00 | data;\n                break;\n            case 3:\n                this.timer = this.timer & 0x00FF | (data << 8) & 0x07FF;\n                this.lengthCounter = table_1.LENGTH_TABLE[data >> 3];\n                this.internalTimer = 0;\n                break;\n        }\n    }\n    step() {\n        this.counter++;\n        if (!this.isEnabled || this.lengthCounter === 0 || this.timer < 8 || this.timer > 0x7FF) {\n            this.volume = 0;\n        }\n        else if (this.isConstantVolume) {\n            this.volume = this.envelopeValue * table_1.DUTY_TABLE[this.duty][this.counter & 0x07];\n        }\n        else {\n            this.volume = this.envelopeVolume * table_1.DUTY_TABLE[this.duty][this.counter & 0x07];\n        }\n    }\n}\nexports.Pulse = Pulse;\n\n\n//# sourceURL=webpack:///./src/apu/pulse.ts?");

/***/ }),

/***/ "./src/apu/table.ts":
/*!**************************!*\
  !*** ./src/apu/table.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LENGTH_TABLE = [\n    10, 254, 20, 2, 40, 4, 80, 6, 160, 8, 60, 10, 14, 12, 26, 14,\n    12, 16, 24, 18, 48, 20, 96, 22, 192, 24, 72, 26, 16, 28, 32, 30,\n];\nexports.NOISE_PEROID_TABLE = [\n    4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068,\n];\nexports.DUTY_TABLE = [\n    [0, 0, 0, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 1, 1],\n    [0, 0, 0, 0, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 1, 0, 0],\n];\nexports.TRIANGLE_VOLUME_TABLE = [\n    15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n];\nexports.DMC_TABLE = [\n    428, 380, 340, 320, 286, 254, 226, 214, 190, 160, 142, 128, 106, 84, 72, 54,\n];\n\n\n//# sourceURL=webpack:///./src/apu/table.ts?");

/***/ }),

/***/ "./src/apu/triangle.ts":
/*!*****************************!*\
  !*** ./src/apu/triangle.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst table_1 = __webpack_require__(/*! ./table */ \"./src/apu/table.ts\");\nclass Triangle {\n    constructor() {\n        this.volume = 0;\n        this.isEnabled = false;\n        this.lengthCounter = 0;\n        this.lenghtCounterHalt = false;\n        this.linearCounterLoad = 0;\n        this.linearCounterReloadFlag = false;\n        this.linearCounterValue = 0;\n        this.timer = 0;\n        this.internalTimer = 0;\n        this.counter = 0;\n    }\n    clock() {\n        if (!this.isEnabled) {\n            return;\n        }\n        if (this.internalTimer === 0) {\n            this.internalTimer = this.timer;\n            this.step();\n        }\n        else {\n            this.internalTimer--;\n        }\n    }\n    processEnvelope() {\n    }\n    processLinearCounter() {\n        if (this.linearCounterReloadFlag) {\n            this.linearCounterValue = this.linearCounterLoad;\n        }\n        else if (this.linearCounterValue > 0) {\n            this.linearCounterValue--;\n        }\n        if (!this.lenghtCounterHalt) {\n            this.linearCounterReloadFlag = false;\n        }\n    }\n    processLengthCounter() {\n        if (!this.lenghtCounterHalt && this.lengthCounter > 0) {\n            this.lengthCounter--;\n        }\n    }\n    processSweep() {\n    }\n    write(offset, data) {\n        switch (offset) {\n            case 0:\n                this.lenghtCounterHalt = !!(data & 0x80);\n                this.linearCounterLoad = data & 0x7F;\n                break;\n            case 1:\n                break;\n            case 2:\n                this.timer = this.timer & 0xFF00 | data;\n                break;\n            case 3:\n                this.timer = this.timer & 0x00FF | (data << 8) & 0x07FF;\n                this.lengthCounter = table_1.LENGTH_TABLE[data >> 3];\n                this.linearCounterReloadFlag = true;\n                this.internalTimer = 0;\n                break;\n        }\n    }\n    step() {\n        this.counter++;\n        if (!this.isEnabled || this.lengthCounter === 0 || this.linearCounterValue === 0) {\n            this.counter--;\n            this.volume = table_1.TRIANGLE_VOLUME_TABLE[this.counter & 0x1F];\n        }\n        else {\n            this.volume = table_1.TRIANGLE_VOLUME_TABLE[this.counter & 0x1F];\n        }\n    }\n}\nexports.Triangle = Triangle;\n\n\n//# sourceURL=webpack:///./src/apu/triangle.ts?");

/***/ }),

/***/ "./src/bus/cpu-bus.ts":
/*!****************************!*\
  !*** ./src/bus/cpu-bus.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass CPUBus {\n    writeByte(address, data) {\n        if (address < 0x2000) {\n            this.ram.write(address & 0x07FF, data);\n        }\n        else if (address < 0x4000) {\n            this.ppu.cpuWrite(address & 0x2007, data);\n        }\n        else if (address === 0x4014) {\n            this.dma.copy(data << 8);\n        }\n        else if (address === 0x4016) {\n            this.controller1.write(data);\n            this.controller2.write(data);\n        }\n        else if (address < 0x4018) {\n            this.apu.write(address, data);\n        }\n        else if (address < 0x4020) {\n        }\n        else {\n            this.cartridge.mapper.write(address, data);\n        }\n    }\n    writeWord(address, data) {\n        this.writeByte(address, data & 0xFF);\n        this.writeByte(address + 1, (data >> 8) & 0xFF);\n    }\n    readByte(address) {\n        if (address < 0x2000) {\n            return this.ram.read(address & 0x07FF);\n        }\n        else if (address < 0x4000) {\n            return this.ppu.cpuRead(address & 0x2007);\n        }\n        else if (address === 0x4014) {\n            return 0;\n        }\n        else if (address === 0x4016 || address === 0x4017) {\n            return address === 0x4016 ? this.controller1.read() : this.controller2.read();\n        }\n        else if (address < 0x4018) {\n            return this.apu.read(address);\n        }\n        else if (address < 0x4020) {\n            return 0;\n        }\n        else {\n            return this.cartridge.mapper.read(address);\n        }\n    }\n    readWord(address) {\n        return (this.readByte(address + 1) << 8 | this.readByte(address)) & 0xFFFF;\n    }\n}\nexports.CPUBus = CPUBus;\n\n\n//# sourceURL=webpack:///./src/bus/cpu-bus.ts?");

/***/ }),

/***/ "./src/bus/ppu-bus.ts":
/*!****************************!*\
  !*** ./src/bus/ppu-bus.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cartridge_1 = __webpack_require__(/*! ../api/cartridge */ \"./src/api/cartridge.ts\");\nclass PPUBus {\n    readByte(address) {\n        address &= 0x3FFF;\n        if (address < 0x2000) {\n            return this.cartridge.mapper.read(address);\n        }\n        else if (address < 0x3000) {\n            return this.ram.read(this.parseMirrorAddress(address));\n        }\n        else if (address < 0x3F00) {\n            return this.readByte(address - 0x1000);\n        }\n        else {\n            address &= 0x3F1F;\n            if (address < 0x3F10) {\n                return this.backgroundPallette.read(address);\n            }\n            else {\n                if (!(address & 0b11)) {\n                    address -= 0x10;\n                    return this.backgroundPallette.read(address);\n                }\n                return this.spritePallette.read(address);\n            }\n        }\n    }\n    writeByte(address, data) {\n        address &= 0x3FFF;\n        if (address < 0x2000) {\n            this.cartridge.mapper.write(address, data);\n        }\n        else if (address < 0x3000) {\n            this.ram.write(this.parseMirrorAddress(address), data);\n        }\n        else if (address < 0x3F00) {\n            return this.writeByte(address - 0x1000, data);\n        }\n        else {\n            address &= 0x3F1F;\n            if (address < 0x3F10) {\n                this.backgroundPallette.write(address, data);\n            }\n            else {\n                if (!(address & 0b11)) {\n                    address -= 0x10;\n                    return this.backgroundPallette.write(address, data);\n                }\n                this.spritePallette.write(address, data);\n            }\n        }\n    }\n    readWord(address) {\n        return this.readByte(address + 1) << 8 | this.readByte(address);\n    }\n    writeWord(address, data) {\n        this.writeByte(address, data);\n        this.writeByte(address + 1, data >> 8);\n    }\n    parseMirrorAddress(address) {\n        switch (this.cartridge.info.mirror) {\n            case cartridge_1.Mirror.HORIZONTAL:\n                return (address & 9215) | (address & 2048 ? 1024 : 0);\n            case cartridge_1.Mirror.VERTICAL:\n                return address & 0x27FF;\n            case cartridge_1.Mirror.FOUR_SCREEN:\n                return address;\n            case cartridge_1.Mirror.SINGLE_SCREEN_LOWER_BANK:\n                return address & 0x23FF;\n            case cartridge_1.Mirror.SINGLE_SCREEN_UPPER_BANK:\n                return address & 0x23FF + 0x0400;\n            default:\n                throw new Error(`Invalid mirror type: '${this.cartridge.info.mirror}'`);\n        }\n    }\n}\nexports.PPUBus = PPUBus;\n\n\n//# sourceURL=webpack:///./src/bus/ppu-bus.ts?");

/***/ }),

/***/ "./src/cartridge/cartridge.ts":
/*!************************************!*\
  !*** ./src/cartridge/cartridge.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mapper0_1 = __webpack_require__(/*! ../mapper/mapper0 */ \"./src/mapper/mapper0.ts\");\nconst cartridge_1 = __webpack_require__(/*! ../api/cartridge */ \"./src/api/cartridge.ts\");\nconst mapper4_1 = __webpack_require__(/*! ../mapper/mapper4 */ \"./src/mapper/mapper4.ts\");\nconst mapper1_1 = __webpack_require__(/*! ../mapper/mapper1 */ \"./src/mapper/mapper1.ts\");\nconst mapper2_1 = __webpack_require__(/*! ../mapper/mapper2 */ \"./src/mapper/mapper2.ts\");\nconst mapper3_1 = __webpack_require__(/*! ../mapper/mapper3 */ \"./src/mapper/mapper3.ts\");\nconst mapper74_1 = __webpack_require__(/*! ../mapper/mapper74 */ \"./src/mapper/mapper74.ts\");\nconst mapper242_1 = __webpack_require__(/*! ../mapper/mapper242 */ \"./src/mapper/mapper242.ts\");\nvar Header;\n(function (Header) {\n    Header[Header[\"PRG\"] = 4] = \"PRG\";\n    Header[Header[\"CHR\"] = 5] = \"CHR\";\n    Header[Header[\"FLAG1\"] = 6] = \"FLAG1\";\n    Header[Header[\"FLAG2\"] = 7] = \"FLAG2\";\n})(Header || (Header = {}));\nclass Cartridge {\n    constructor(data, sram) {\n        this.info = {};\n        Cartridge.checkConstant(data);\n        this.parseROMInfo(data);\n        const prgOffset = this.info.isTrained ? 16 + 512 : 16;\n        const prg = data.slice(prgOffset, prgOffset + this.info.prg * 16 * 1024);\n        const chrOffset = prgOffset + prg.length;\n        const chr = data.slice(chrOffset, chrOffset + this.info.chr * 8 * 1024);\n        switch (this.info.mapper) {\n            case 0:\n                this.mapper = new mapper0_1.Mapper0(this, sram, prg, chr);\n                break;\n            case 1:\n                this.mapper = new mapper1_1.Mapper1(this, sram, prg, chr);\n                break;\n            case 2:\n                this.mapper = new mapper2_1.Mapper2(this, sram, prg, chr);\n                break;\n            case 3:\n                this.mapper = new mapper3_1.Mapper3(this, sram, prg, chr);\n                break;\n            case 4:\n                this.mapper = new mapper4_1.Mapper4(this, sram, prg, chr);\n                break;\n            case 74:\n                this.mapper = new mapper74_1.Mapper74(this, sram, prg, chr);\n                break;\n            case 242:\n                this.mapper = new mapper242_1.Mapper242(this, sram, prg, chr);\n                break;\n            default:\n                throw new Error(`Unsupported mapper: ${this.info.mapper}`);\n        }\n    }\n    parseROMInfo(data) {\n        this.info.prg = data[Header.PRG];\n        this.info.chr = data[Header.CHR];\n        const mapperL = data[Header.FLAG1] >> 4;\n        const mapperH = data[Header.FLAG2] >> 4;\n        this.info.mapper = mapperH << 4 | mapperL;\n        this.info.mirror = data[Header.FLAG1] & 0x08 ? cartridge_1.Mirror.FOUR_SCREEN :\n            data[Header.FLAG1] & 0x01 ? cartridge_1.Mirror.VERTICAL : cartridge_1.Mirror.HORIZONTAL;\n        this.info.hasBatteryBacked = !!(data[Header.FLAG1] & 0x02);\n        this.info.isTrained = !!(data[Header.FLAG1] & 0x04);\n    }\n    static checkConstant(data) {\n        const str = 'NES\\u001a';\n        for (let i = 0; i < str.length; i++) {\n            if (data[i] !== str.charCodeAt(i)) {\n                throw new Error('Invalid nes file');\n            }\n        }\n        if ((data[7] & 0x0C) === 0x08) {\n            throw new Error('NES2.0 is not currently supported');\n        }\n    }\n}\nexports.Cartridge = Cartridge;\n\n\n//# sourceURL=webpack:///./src/cartridge/cartridge.ts?");

/***/ }),

/***/ "./src/controller/standard-controller.ts":
/*!***********************************************!*\
  !*** ./src/controller/standard-controller.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst controller_1 = __webpack_require__(/*! ../api/controller */ \"./src/api/controller.ts\");\nclass StandardController {\n    constructor() {\n        this.isStrobe = false;\n        this.offset = 0;\n    }\n    updateButton(button, isPressDown) {\n        if (isPressDown) {\n            this.data |= button;\n        }\n        else {\n            this.data &= ~button & 0xFF;\n        }\n    }\n    write(data) {\n        if (data & 0x01) {\n            this.isStrobe = true;\n        }\n        else {\n            this.offset = 0;\n            this.isStrobe = false;\n        }\n    }\n    read() {\n        const data = this.isStrobe ? this.data & controller_1.StandardControllerButton.A : this.data & (0x80 >> this.offset++);\n        return data ? 1 : 0;\n    }\n}\nexports.StandardController = StandardController;\n\n\n//# sourceURL=webpack:///./src/controller/standard-controller.ts?");

/***/ }),

/***/ "./src/cpu/cpu.ts":
/*!************************!*\
  !*** ./src/cpu/cpu.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cpu_1 = __webpack_require__(/*! ../api/cpu */ \"./src/api/cpu.ts\");\nconst registers_1 = __webpack_require__(/*! ./registers */ \"./src/cpu/registers.ts\");\nconst opcode_table_1 = __webpack_require__(/*! ./opcode-table */ \"./src/cpu/opcode-table.ts\");\nvar InterruptVector;\n(function (InterruptVector) {\n    InterruptVector[InterruptVector[\"NMI\"] = 65530] = \"NMI\";\n    InterruptVector[InterruptVector[\"RESET\"] = 65532] = \"RESET\";\n    InterruptVector[InterruptVector[\"IRQ\"] = 65534] = \"IRQ\";\n})(InterruptVector || (InterruptVector = {}));\nclass CPU {\n    constructor() {\n        this.suspendCycles = 0;\n        this.clocks = 0;\n        this.deferCycles = 0;\n        this.registers = new registers_1.Registers();\n        this.instructionMap = new Map([\n            [opcode_table_1.Instruction.ADC, this.adc],\n            [opcode_table_1.Instruction.AND, this.and],\n            [opcode_table_1.Instruction.ASL, this.asl],\n            [opcode_table_1.Instruction.BCC, this.bcc],\n            [opcode_table_1.Instruction.BCS, this.bcs],\n            [opcode_table_1.Instruction.BEQ, this.beq],\n            [opcode_table_1.Instruction.BIT, this.bit],\n            [opcode_table_1.Instruction.BMI, this.bmi],\n            [opcode_table_1.Instruction.BNE, this.bne],\n            [opcode_table_1.Instruction.BPL, this.bpl],\n            [opcode_table_1.Instruction.BRK, this.brk],\n            [opcode_table_1.Instruction.BVC, this.bvc],\n            [opcode_table_1.Instruction.BVS, this.bvs],\n            [opcode_table_1.Instruction.CLC, this.clc],\n            [opcode_table_1.Instruction.CLD, this.cld],\n            [opcode_table_1.Instruction.CLI, this.cli],\n            [opcode_table_1.Instruction.CLV, this.clv],\n            [opcode_table_1.Instruction.CMP, this.cmp],\n            [opcode_table_1.Instruction.CPX, this.cpx],\n            [opcode_table_1.Instruction.CPY, this.cpy],\n            [opcode_table_1.Instruction.DEC, this.dec],\n            [opcode_table_1.Instruction.DEX, this.dex],\n            [opcode_table_1.Instruction.DEY, this.dey],\n            [opcode_table_1.Instruction.EOR, this.eor],\n            [opcode_table_1.Instruction.INC, this.inc],\n            [opcode_table_1.Instruction.INX, this.inx],\n            [opcode_table_1.Instruction.INY, this.iny],\n            [opcode_table_1.Instruction.JMP, this.jmp],\n            [opcode_table_1.Instruction.JSR, this.jsr],\n            [opcode_table_1.Instruction.LDA, this.lda],\n            [opcode_table_1.Instruction.LDX, this.ldx],\n            [opcode_table_1.Instruction.LDY, this.ldy],\n            [opcode_table_1.Instruction.LSR, this.lsr],\n            [opcode_table_1.Instruction.NOP, this.nop],\n            [opcode_table_1.Instruction.ORA, this.ora],\n            [opcode_table_1.Instruction.PHA, this.pha],\n            [opcode_table_1.Instruction.PHP, this.php],\n            [opcode_table_1.Instruction.PLA, this.pla],\n            [opcode_table_1.Instruction.PLP, this.plp],\n            [opcode_table_1.Instruction.ROL, this.rol],\n            [opcode_table_1.Instruction.ROR, this.ror],\n            [opcode_table_1.Instruction.RTI, this.rti],\n            [opcode_table_1.Instruction.RTS, this.rts],\n            [opcode_table_1.Instruction.SBC, this.sbc],\n            [opcode_table_1.Instruction.SEC, this.sec],\n            [opcode_table_1.Instruction.SED, this.sed],\n            [opcode_table_1.Instruction.SEI, this.sei],\n            [opcode_table_1.Instruction.STA, this.sta],\n            [opcode_table_1.Instruction.STX, this.stx],\n            [opcode_table_1.Instruction.STY, this.sty],\n            [opcode_table_1.Instruction.TAX, this.tax],\n            [opcode_table_1.Instruction.TAY, this.tay],\n            [opcode_table_1.Instruction.TSX, this.tsx],\n            [opcode_table_1.Instruction.TXA, this.txa],\n            [opcode_table_1.Instruction.TXS, this.txs],\n            [opcode_table_1.Instruction.TYA, this.tya],\n            [opcode_table_1.Instruction.DCP, this.dcp],\n            [opcode_table_1.Instruction.ISC, this.isc],\n            [opcode_table_1.Instruction.LAX, this.lax],\n            [opcode_table_1.Instruction.RLA, this.rla],\n            [opcode_table_1.Instruction.RRA, this.rra],\n            [opcode_table_1.Instruction.SAX, this.sax],\n            [opcode_table_1.Instruction.SLO, this.slo],\n            [opcode_table_1.Instruction.SRE, this.sre],\n        ]);\n        this.addressingModeMap = new Map([\n            [opcode_table_1.AddressingMode.ABSOLUTE, this.absolute],\n            [opcode_table_1.AddressingMode.ABSOLUTE_X, this.absoluteX],\n            [opcode_table_1.AddressingMode.ABSOLUTE_Y, this.absoluteY],\n            [opcode_table_1.AddressingMode.ACCUMULATOR, this.accumulator],\n            [opcode_table_1.AddressingMode.IMMEDIATE, this.immediate],\n            [opcode_table_1.AddressingMode.IMPLICIT, this.implicit],\n            [opcode_table_1.AddressingMode.INDIRECT, this.indirect],\n            [opcode_table_1.AddressingMode.INDIRECT_Y_INDEXED, this.indirectYIndexed],\n            [opcode_table_1.AddressingMode.RELATIVE, this.relative],\n            [opcode_table_1.AddressingMode.X_INDEXED_INDIRECT, this.xIndexedIndirect],\n            [opcode_table_1.AddressingMode.ZERO_PAGE, this.zeroPage],\n            [opcode_table_1.AddressingMode.ZERO_PAGE_X, this.zeroPageX],\n            [opcode_table_1.AddressingMode.ZERO_PAGE_Y, this.zeroPageY],\n        ]);\n    }\n    reset() {\n        this.registers.A = 0;\n        this.registers.X = 0;\n        this.registers.Y = 0;\n        this.registers.P = 0;\n        this.registers.SP = 0xfd;\n        this.registers.PC = this.bus.readWord(InterruptVector.RESET);\n        this.deferCycles = 8;\n        this.clocks = 0;\n    }\n    clock() {\n        if (this.suspendCycles > 0) {\n            this.suspendCycles--;\n            return;\n        }\n        if (this.deferCycles === 0) {\n            this.step();\n        }\n        this.deferCycles--;\n        this.clocks++;\n    }\n    irq() {\n        if (this.isFlagSet(cpu_1.Flags.I)) {\n            return;\n        }\n        this.pushWord(this.registers.PC);\n        this.pushByte((this.registers.P | cpu_1.Flags.U) & ~cpu_1.Flags.B);\n        this.setFlag(cpu_1.Flags.I, true);\n        this.registers.PC = this.bus.readWord(InterruptVector.IRQ);\n        this.deferCycles += 7;\n    }\n    nmi() {\n        this.pushWord(this.registers.PC);\n        this.pushByte((this.registers.P | cpu_1.Flags.U) & ~cpu_1.Flags.B);\n        this.setFlag(cpu_1.Flags.I, true);\n        this.registers.PC = this.bus.readWord(InterruptVector.NMI);\n        this.deferCycles += 7;\n    }\n    setFlag(flag, value) {\n        if (value) {\n            this.registers.P |= flag;\n        }\n        else {\n            this.registers.P &= ~flag;\n        }\n    }\n    isFlagSet(flag) {\n        return !!(this.registers.P & flag);\n    }\n    step() {\n        const opcode = this.bus.readByte(this.registers.PC++);\n        const entry = opcode_table_1.default[opcode];\n        if (!entry) {\n            throw new Error(`Invalid opcode '${opcode}(0x${opcode.toString(16)})', pc: 0x${(this.registers.PC - 1).toString(16)}`);\n        }\n        if (entry.instruction === opcode_table_1.Instruction.INVALID) {\n            return;\n        }\n        const addrModeFunc = this.addressingModeMap.get(entry.addressingMode);\n        if (!addrModeFunc) {\n            throw new Error(`Unsuppored addressing mode: ${opcode_table_1.AddressingMode[entry.addressingMode]}`);\n        }\n        const ret = addrModeFunc.call(this);\n        if (ret.isCrossPage) {\n            this.deferCycles += entry.pageCycles;\n        }\n        const instrFunc = this.instructionMap.get(entry.instruction);\n        if (!instrFunc) {\n            throw new Error(`Unsupported instruction: ${opcode_table_1.Instruction[entry.instruction]}`);\n        }\n        instrFunc.call(this, ret, entry.addressingMode);\n        this.deferCycles += entry.cycles;\n    }\n    pushWord(data) {\n        this.pushByte(data >> 8);\n        this.pushByte(data);\n    }\n    pushByte(data) {\n        this.bus.writeByte(0x100 + this.registers.SP, data);\n        this.registers.SP = (this.registers.SP - 1) & 0xFF;\n    }\n    popWord() {\n        return this.popByte() | this.popByte() << 8;\n    }\n    popByte() {\n        this.registers.SP = (this.registers.SP + 1) & 0xFF;\n        return this.bus.readByte(0x100 + this.registers.SP);\n    }\n    setNZFlag(data) {\n        this.setFlag(cpu_1.Flags.Z, (data & 0xFF) === 0);\n        this.setFlag(cpu_1.Flags.N, !!(data & 0x80));\n    }\n    getData(addrData) {\n        if (!isNaN(addrData.data)) {\n            return addrData.data;\n        }\n        else {\n            return this.bus.readByte(addrData.address);\n        }\n    }\n    absolute() {\n        const address = this.bus.readWord(this.registers.PC);\n        this.registers.PC += 2;\n        return {\n            address: address & 0xFFFF,\n            data: NaN,\n            isCrossPage: false,\n        };\n    }\n    absoluteX() {\n        const baseAddress = this.bus.readWord(this.registers.PC);\n        this.registers.PC += 2;\n        const address = baseAddress + this.registers.X;\n        return {\n            address: address & 0xFFFF,\n            data: NaN,\n            isCrossPage: this.isCrossPage(baseAddress, address),\n        };\n    }\n    absoluteY() {\n        const baseAddress = this.bus.readWord(this.registers.PC);\n        this.registers.PC += 2;\n        const address = baseAddress + this.registers.Y;\n        return {\n            address: address & 0xFFFF,\n            data: NaN,\n            isCrossPage: this.isCrossPage(baseAddress, address),\n        };\n    }\n    accumulator() {\n        return {\n            address: NaN,\n            data: this.registers.A,\n            isCrossPage: false,\n        };\n    }\n    immediate() {\n        return {\n            address: NaN,\n            data: this.bus.readByte(this.registers.PC++),\n            isCrossPage: false,\n        };\n    }\n    implicit() {\n        return {\n            address: NaN,\n            data: NaN,\n            isCrossPage: false,\n        };\n    }\n    indirect() {\n        let address = this.bus.readWord(this.registers.PC);\n        this.registers.PC += 2;\n        if ((address & 0xFF) === 0xFF) {\n            address = this.bus.readByte(address & 0xFF00) << 8 | this.bus.readByte(address);\n        }\n        else {\n            address = this.bus.readWord(address);\n        }\n        return {\n            address: address & 0xFFFF,\n            data: NaN,\n            isCrossPage: false,\n        };\n    }\n    indirectYIndexed() {\n        const value = this.bus.readByte(this.registers.PC++);\n        const l = this.bus.readByte(value & 0xFF);\n        const h = this.bus.readByte((value + 1) & 0xFF);\n        const baseAddress = h << 8 | l;\n        const address = baseAddress + this.registers.Y;\n        return {\n            address: address & 0xFFFF,\n            data: NaN,\n            isCrossPage: this.isCrossPage(baseAddress, address),\n        };\n    }\n    relative() {\n        let offset = this.bus.readByte(this.registers.PC++);\n        if (offset & 0x80) {\n            offset = offset - 0x100;\n        }\n        return {\n            address: (this.registers.PC + offset) & 0xFFFF,\n            data: NaN,\n            isCrossPage: false,\n        };\n    }\n    xIndexedIndirect() {\n        const value = this.bus.readByte(this.registers.PC++);\n        const address = (value + this.registers.X);\n        const l = this.bus.readByte(address & 0xFF);\n        const h = this.bus.readByte((address + 1) & 0xFF);\n        return {\n            address: (h << 8 | l) & 0xFFFF,\n            data: NaN,\n            isCrossPage: false,\n        };\n    }\n    zeroPage() {\n        const address = this.bus.readByte(this.registers.PC++);\n        return {\n            address: address & 0xFFFF,\n            data: NaN,\n            isCrossPage: false,\n        };\n    }\n    zeroPageX() {\n        const address = (this.bus.readByte(this.registers.PC++) + this.registers.X) & 0xFF;\n        return {\n            address: address & 0xFFFF,\n            data: NaN,\n            isCrossPage: false,\n        };\n    }\n    zeroPageY() {\n        const address = (this.bus.readByte(this.registers.PC++) + this.registers.Y) & 0xFF;\n        return {\n            address: address & 0xFFFF,\n            data: NaN,\n            isCrossPage: false,\n        };\n    }\n    adc(addrData) {\n        const data = this.getData(addrData);\n        const value = data + this.registers.A + (this.isFlagSet(cpu_1.Flags.C) ? 1 : 0);\n        this.setFlag(cpu_1.Flags.C, value > 0xFF);\n        this.setFlag(cpu_1.Flags.V, !!((~(this.registers.A ^ data) & (this.registers.A ^ value)) & 0x80));\n        this.setNZFlag(value);\n        this.registers.A = value & 0xFF;\n    }\n    and(addrData) {\n        this.registers.A &= this.getData(addrData);\n        this.setNZFlag(this.registers.A);\n    }\n    asl(addrData) {\n        let data = this.getData(addrData) << 1;\n        this.setFlag(cpu_1.Flags.C, !!(data & 0x100));\n        data = data & 0xFF;\n        this.setNZFlag(data);\n        if (isNaN(addrData.address)) {\n            this.registers.A = data;\n        }\n        else {\n            this.bus.writeByte(addrData.address, data);\n        }\n    }\n    bcc(addrData) {\n        if (!this.isFlagSet(cpu_1.Flags.C)) {\n            this.deferCycles++;\n            if (this.isCrossPage(this.registers.PC, addrData.address)) {\n                this.deferCycles++;\n            }\n            this.registers.PC = addrData.address;\n        }\n    }\n    bcs(addrData) {\n        if (this.isFlagSet(cpu_1.Flags.C)) {\n            this.deferCycles++;\n            if (this.isCrossPage(this.registers.PC, addrData.address)) {\n                this.deferCycles++;\n            }\n            this.registers.PC = addrData.address;\n        }\n    }\n    beq(addrData) {\n        if (this.isFlagSet(cpu_1.Flags.Z)) {\n            this.deferCycles++;\n            if (this.isCrossPage(this.registers.PC, addrData.address)) {\n                this.deferCycles++;\n            }\n            this.registers.PC = addrData.address;\n        }\n    }\n    bit(addrData) {\n        const data = this.getData(addrData);\n        this.setFlag(cpu_1.Flags.Z, !(this.registers.A & data));\n        this.setFlag(cpu_1.Flags.N, !!(data & (1 << 7)));\n        this.setFlag(cpu_1.Flags.V, !!(data & (1 << 6)));\n    }\n    bmi(addrData) {\n        if (this.isFlagSet(cpu_1.Flags.N)) {\n            this.deferCycles++;\n            if (this.isCrossPage(this.registers.PC, addrData.address)) {\n                this.deferCycles++;\n            }\n            this.registers.PC = addrData.address;\n        }\n    }\n    bne(addrData) {\n        if (!this.isFlagSet(cpu_1.Flags.Z)) {\n            this.deferCycles++;\n            if (this.isCrossPage(this.registers.PC, addrData.address)) {\n                this.deferCycles++;\n            }\n            this.registers.PC = addrData.address;\n        }\n    }\n    bpl(addrData) {\n        if (!this.isFlagSet(cpu_1.Flags.N)) {\n            this.deferCycles++;\n            if (this.isCrossPage(this.registers.PC, addrData.address)) {\n                this.deferCycles++;\n            }\n            this.registers.PC = addrData.address;\n        }\n    }\n    brk(addrData) {\n        this.pushWord(this.registers.PC);\n        this.pushByte(this.registers.P | cpu_1.Flags.B | cpu_1.Flags.U);\n        this.setFlag(cpu_1.Flags.I, true);\n        this.registers.PC = this.bus.readWord(InterruptVector.IRQ);\n    }\n    bvc(addrData) {\n        if (!this.isFlagSet(cpu_1.Flags.V)) {\n            this.deferCycles++;\n            if (this.isCrossPage(this.registers.PC, addrData.address)) {\n                this.deferCycles++;\n            }\n            this.registers.PC = addrData.address;\n        }\n    }\n    bvs(addrData) {\n        if (this.isFlagSet(cpu_1.Flags.V)) {\n            this.deferCycles++;\n            if (this.isCrossPage(this.registers.PC, addrData.address)) {\n                this.deferCycles++;\n            }\n            this.registers.PC = addrData.address;\n        }\n    }\n    clc(addrData) {\n        this.setFlag(cpu_1.Flags.C, false);\n    }\n    cld(addrData) {\n        this.setFlag(cpu_1.Flags.D, false);\n    }\n    cli(addrData) {\n        this.setFlag(cpu_1.Flags.I, false);\n    }\n    clv(addrData) {\n        this.setFlag(cpu_1.Flags.V, false);\n    }\n    cmp(addrData) {\n        const data = this.getData(addrData);\n        const res = this.registers.A - data;\n        this.setFlag(cpu_1.Flags.C, this.registers.A >= data);\n        this.setNZFlag(res);\n    }\n    cpx(addrData) {\n        const data = this.getData(addrData);\n        const res = this.registers.X - data;\n        this.setFlag(cpu_1.Flags.C, this.registers.X >= data);\n        this.setNZFlag(res);\n    }\n    cpy(addrData) {\n        const data = this.getData(addrData);\n        const res = this.registers.Y - data;\n        this.setFlag(cpu_1.Flags.C, this.registers.Y >= data);\n        this.setNZFlag(res);\n    }\n    dec(addrData) {\n        const data = (this.getData(addrData) - 1) & 0xFF;\n        this.bus.writeByte(addrData.address, data);\n        this.setNZFlag(data);\n    }\n    dex(addrData) {\n        this.registers.X = (this.registers.X - 1) & 0xFF;\n        this.setNZFlag(this.registers.X);\n    }\n    dey(addrData) {\n        this.registers.Y = (this.registers.Y - 1) & 0xFF;\n        this.setNZFlag(this.registers.Y);\n    }\n    eor(addrData) {\n        this.registers.A ^= this.getData(addrData);\n        this.setNZFlag(this.registers.A);\n    }\n    inc(addrData) {\n        const data = (this.getData(addrData) + 1) & 0xFF;\n        this.bus.writeByte(addrData.address, data);\n        this.setNZFlag(data);\n    }\n    inx(addrData) {\n        this.registers.X = (this.registers.X + 1) & 0xFF;\n        this.setNZFlag(this.registers.X);\n    }\n    iny(addrData) {\n        this.registers.Y = (this.registers.Y + 1) & 0xFF;\n        this.setNZFlag(this.registers.Y);\n    }\n    jmp(addrData) {\n        this.registers.PC = addrData.address;\n    }\n    jsr(addrData) {\n        this.pushWord(this.registers.PC - 1);\n        this.registers.PC = addrData.address;\n    }\n    lda(addrData) {\n        this.registers.A = this.getData(addrData);\n        this.setNZFlag(this.registers.A);\n    }\n    ldx(addrData) {\n        this.registers.X = this.getData(addrData);\n        this.setNZFlag(this.registers.X);\n    }\n    ldy(addrData) {\n        this.registers.Y = this.getData(addrData);\n        this.setNZFlag(this.registers.Y);\n    }\n    lsr(addrData) {\n        let data = this.getData(addrData);\n        this.setFlag(cpu_1.Flags.C, !!(data & 0x01));\n        data >>= 1;\n        this.setNZFlag(data);\n        if (isNaN(addrData.address)) {\n            this.registers.A = data;\n        }\n        else {\n            this.bus.writeByte(addrData.address, data);\n        }\n    }\n    nop(addrData) {\n    }\n    ora(addrData) {\n        this.registers.A |= this.getData(addrData);\n        this.setNZFlag(this.registers.A);\n    }\n    pha(addrData) {\n        this.pushByte(this.registers.A);\n    }\n    php(addrData) {\n        this.pushByte(this.registers.P | cpu_1.Flags.B | cpu_1.Flags.U);\n    }\n    pla(addrData) {\n        this.registers.A = this.popByte();\n        this.setNZFlag(this.registers.A);\n    }\n    plp(addrData) {\n        this.registers.P = this.popByte();\n        this.setFlag(cpu_1.Flags.B, false);\n        this.setFlag(cpu_1.Flags.U, false);\n    }\n    rol(addrData) {\n        let data = this.getData(addrData);\n        const isCarry = this.isFlagSet(cpu_1.Flags.C);\n        this.setFlag(cpu_1.Flags.C, !!(data & 0x80));\n        data = (data << 1 | (isCarry ? 1 : 0)) & 0xFF;\n        this.setNZFlag(data);\n        if (isNaN(addrData.address)) {\n            this.registers.A = data;\n        }\n        else {\n            this.bus.writeByte(addrData.address, data);\n        }\n    }\n    ror(addrData) {\n        let data = this.getData(addrData);\n        const isCarry = this.isFlagSet(cpu_1.Flags.C);\n        this.setFlag(cpu_1.Flags.C, !!(data & 1));\n        data = data >> 1 | (isCarry ? 1 << 7 : 0);\n        this.setNZFlag(data);\n        if (isNaN(addrData.address)) {\n            this.registers.A = data;\n        }\n        else {\n            this.bus.writeByte(addrData.address, data);\n        }\n    }\n    rti(addrData) {\n        this.registers.P = this.popByte();\n        this.setFlag(cpu_1.Flags.B, false);\n        this.setFlag(cpu_1.Flags.U, false);\n        this.registers.PC = this.popWord();\n    }\n    rts(addrData) {\n        this.registers.PC = this.popWord() + 1;\n    }\n    sbc(addrData) {\n        const data = this.getData(addrData);\n        const res = this.registers.A - data - (this.isFlagSet(cpu_1.Flags.C) ? 0 : 1);\n        this.setNZFlag(res);\n        this.setFlag(cpu_1.Flags.C, res >= 0);\n        this.setFlag(cpu_1.Flags.V, !!((res ^ this.registers.A) & (res ^ data ^ 0xFF) & 0x0080));\n        this.registers.A = res & 0xFF;\n    }\n    sec(addrData) {\n        this.setFlag(cpu_1.Flags.C, true);\n    }\n    sed(addrData) {\n        this.setFlag(cpu_1.Flags.D, true);\n    }\n    sei(addrData) {\n        this.setFlag(cpu_1.Flags.I, true);\n    }\n    sta(addrData) {\n        this.bus.writeByte(addrData.address, this.registers.A);\n    }\n    stx(addrData) {\n        this.bus.writeByte(addrData.address, this.registers.X);\n    }\n    sty(addrData) {\n        this.bus.writeByte(addrData.address, this.registers.Y);\n    }\n    tax(addrData) {\n        this.registers.X = this.registers.A;\n        this.setNZFlag(this.registers.X);\n    }\n    tay(addrData) {\n        this.registers.Y = this.registers.A;\n        this.setNZFlag(this.registers.Y);\n    }\n    tsx(addrData) {\n        this.registers.X = this.registers.SP;\n        this.setNZFlag(this.registers.X);\n    }\n    txa(addrData) {\n        this.registers.A = this.registers.X;\n        this.setNZFlag(this.registers.A);\n    }\n    txs(addrData) {\n        this.registers.SP = this.registers.X;\n    }\n    tya(addrData) {\n        this.registers.A = this.registers.Y;\n        this.setNZFlag(this.registers.A);\n    }\n    dcp(addrData) {\n        this.dec(addrData);\n        this.cmp(addrData);\n    }\n    isc(addrData) {\n        this.inc(addrData);\n        this.sbc(addrData);\n    }\n    lax(addrData) {\n        this.lda(addrData);\n        this.ldx(addrData);\n    }\n    rla(addrData) {\n        this.rol(addrData);\n        this.and(addrData);\n    }\n    rra(addrData) {\n        this.ror(addrData);\n        this.adc(addrData);\n    }\n    sax(addrData) {\n        const value = this.registers.A & this.registers.X;\n        this.bus.writeByte(addrData.address, value);\n    }\n    slo(addrData) {\n        this.asl(addrData);\n        this.ora(addrData);\n    }\n    sre(addrData) {\n        this.lsr(addrData);\n        this.eor(addrData);\n    }\n    isCrossPage(addr1, addr2) {\n        return (addr1 & 0xff00) !== (addr2 & 0xff00);\n    }\n}\nexports.CPU = CPU;\n\n\n//# sourceURL=webpack:///./src/cpu/cpu.ts?");

/***/ }),

/***/ "./src/cpu/opcode-table.ts":
/*!*********************************!*\
  !*** ./src/cpu/opcode-table.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Instruction;\n(function (Instruction) {\n    Instruction[Instruction[\"ADC\"] = 0] = \"ADC\";\n    Instruction[Instruction[\"AND\"] = 1] = \"AND\";\n    Instruction[Instruction[\"ASL\"] = 2] = \"ASL\";\n    Instruction[Instruction[\"BCC\"] = 3] = \"BCC\";\n    Instruction[Instruction[\"BCS\"] = 4] = \"BCS\";\n    Instruction[Instruction[\"BEQ\"] = 5] = \"BEQ\";\n    Instruction[Instruction[\"BIT\"] = 6] = \"BIT\";\n    Instruction[Instruction[\"BMI\"] = 7] = \"BMI\";\n    Instruction[Instruction[\"BNE\"] = 8] = \"BNE\";\n    Instruction[Instruction[\"BPL\"] = 9] = \"BPL\";\n    Instruction[Instruction[\"BRK\"] = 10] = \"BRK\";\n    Instruction[Instruction[\"BVC\"] = 11] = \"BVC\";\n    Instruction[Instruction[\"BVS\"] = 12] = \"BVS\";\n    Instruction[Instruction[\"CLC\"] = 13] = \"CLC\";\n    Instruction[Instruction[\"CLD\"] = 14] = \"CLD\";\n    Instruction[Instruction[\"CLI\"] = 15] = \"CLI\";\n    Instruction[Instruction[\"CLV\"] = 16] = \"CLV\";\n    Instruction[Instruction[\"CMP\"] = 17] = \"CMP\";\n    Instruction[Instruction[\"CPX\"] = 18] = \"CPX\";\n    Instruction[Instruction[\"CPY\"] = 19] = \"CPY\";\n    Instruction[Instruction[\"DEC\"] = 20] = \"DEC\";\n    Instruction[Instruction[\"DEX\"] = 21] = \"DEX\";\n    Instruction[Instruction[\"DEY\"] = 22] = \"DEY\";\n    Instruction[Instruction[\"EOR\"] = 23] = \"EOR\";\n    Instruction[Instruction[\"INC\"] = 24] = \"INC\";\n    Instruction[Instruction[\"INX\"] = 25] = \"INX\";\n    Instruction[Instruction[\"INY\"] = 26] = \"INY\";\n    Instruction[Instruction[\"JMP\"] = 27] = \"JMP\";\n    Instruction[Instruction[\"JSR\"] = 28] = \"JSR\";\n    Instruction[Instruction[\"LDA\"] = 29] = \"LDA\";\n    Instruction[Instruction[\"LDX\"] = 30] = \"LDX\";\n    Instruction[Instruction[\"LDY\"] = 31] = \"LDY\";\n    Instruction[Instruction[\"LSR\"] = 32] = \"LSR\";\n    Instruction[Instruction[\"NOP\"] = 33] = \"NOP\";\n    Instruction[Instruction[\"ORA\"] = 34] = \"ORA\";\n    Instruction[Instruction[\"PHA\"] = 35] = \"PHA\";\n    Instruction[Instruction[\"PHP\"] = 36] = \"PHP\";\n    Instruction[Instruction[\"PLA\"] = 37] = \"PLA\";\n    Instruction[Instruction[\"PLP\"] = 38] = \"PLP\";\n    Instruction[Instruction[\"ROL\"] = 39] = \"ROL\";\n    Instruction[Instruction[\"ROR\"] = 40] = \"ROR\";\n    Instruction[Instruction[\"RTI\"] = 41] = \"RTI\";\n    Instruction[Instruction[\"RTS\"] = 42] = \"RTS\";\n    Instruction[Instruction[\"SBC\"] = 43] = \"SBC\";\n    Instruction[Instruction[\"SEC\"] = 44] = \"SEC\";\n    Instruction[Instruction[\"SED\"] = 45] = \"SED\";\n    Instruction[Instruction[\"SEI\"] = 46] = \"SEI\";\n    Instruction[Instruction[\"STA\"] = 47] = \"STA\";\n    Instruction[Instruction[\"STX\"] = 48] = \"STX\";\n    Instruction[Instruction[\"STY\"] = 49] = \"STY\";\n    Instruction[Instruction[\"TAX\"] = 50] = \"TAX\";\n    Instruction[Instruction[\"TAY\"] = 51] = \"TAY\";\n    Instruction[Instruction[\"TSX\"] = 52] = \"TSX\";\n    Instruction[Instruction[\"TXA\"] = 53] = \"TXA\";\n    Instruction[Instruction[\"TXS\"] = 54] = \"TXS\";\n    Instruction[Instruction[\"TYA\"] = 55] = \"TYA\";\n    Instruction[Instruction[\"DCP\"] = 56] = \"DCP\";\n    Instruction[Instruction[\"ISC\"] = 57] = \"ISC\";\n    Instruction[Instruction[\"LAX\"] = 58] = \"LAX\";\n    Instruction[Instruction[\"RLA\"] = 59] = \"RLA\";\n    Instruction[Instruction[\"RRA\"] = 60] = \"RRA\";\n    Instruction[Instruction[\"SAX\"] = 61] = \"SAX\";\n    Instruction[Instruction[\"SLO\"] = 62] = \"SLO\";\n    Instruction[Instruction[\"SRE\"] = 63] = \"SRE\";\n    Instruction[Instruction[\"INVALID\"] = 64] = \"INVALID\";\n})(Instruction = exports.Instruction || (exports.Instruction = {}));\nvar AddressingMode;\n(function (AddressingMode) {\n    AddressingMode[AddressingMode[\"IMPLICIT\"] = 0] = \"IMPLICIT\";\n    AddressingMode[AddressingMode[\"ACCUMULATOR\"] = 1] = \"ACCUMULATOR\";\n    AddressingMode[AddressingMode[\"IMMEDIATE\"] = 2] = \"IMMEDIATE\";\n    AddressingMode[AddressingMode[\"ZERO_PAGE\"] = 3] = \"ZERO_PAGE\";\n    AddressingMode[AddressingMode[\"ZERO_PAGE_X\"] = 4] = \"ZERO_PAGE_X\";\n    AddressingMode[AddressingMode[\"ZERO_PAGE_Y\"] = 5] = \"ZERO_PAGE_Y\";\n    AddressingMode[AddressingMode[\"RELATIVE\"] = 6] = \"RELATIVE\";\n    AddressingMode[AddressingMode[\"ABSOLUTE\"] = 7] = \"ABSOLUTE\";\n    AddressingMode[AddressingMode[\"ABSOLUTE_X\"] = 8] = \"ABSOLUTE_X\";\n    AddressingMode[AddressingMode[\"ABSOLUTE_Y\"] = 9] = \"ABSOLUTE_Y\";\n    AddressingMode[AddressingMode[\"INDIRECT\"] = 10] = \"INDIRECT\";\n    AddressingMode[AddressingMode[\"X_INDEXED_INDIRECT\"] = 11] = \"X_INDEXED_INDIRECT\";\n    AddressingMode[AddressingMode[\"INDIRECT_Y_INDEXED\"] = 12] = \"INDIRECT_Y_INDEXED\";\n})(AddressingMode = exports.AddressingMode || (exports.AddressingMode = {}));\nconst OPCODE_TABLE = [\n    E(Instruction.BRK, AddressingMode.ZERO_PAGE, 2, 7, 0),\n    E(Instruction.ORA, AddressingMode.X_INDEXED_INDIRECT, 2, 6, 0),\n    undefined,\n    E(Instruction.SLO, AddressingMode.X_INDEXED_INDIRECT, 2, 8, 0),\n    E(Instruction.NOP, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.ORA, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.ASL, AddressingMode.ZERO_PAGE, 2, 5, 0),\n    E(Instruction.SLO, AddressingMode.ZERO_PAGE, 2, 5, 0),\n    E(Instruction.PHP, AddressingMode.IMPLICIT, 1, 3, 0),\n    E(Instruction.ORA, AddressingMode.IMMEDIATE, 2, 2, 0),\n    E(Instruction.ASL, AddressingMode.ACCUMULATOR, 1, 2, 0),\n    undefined,\n    E(Instruction.NOP, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.ORA, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.ASL, AddressingMode.ABSOLUTE, 3, 6, 0),\n    E(Instruction.SLO, AddressingMode.ABSOLUTE, 3, 6, 0),\n    E(Instruction.BPL, AddressingMode.RELATIVE, 2, 2, 1),\n    E(Instruction.ORA, AddressingMode.INDIRECT_Y_INDEXED, 2, 5, 1),\n    undefined,\n    E(Instruction.SLO, AddressingMode.INDIRECT_Y_INDEXED, 2, 8, 0),\n    E(Instruction.NOP, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.ORA, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.ASL, AddressingMode.ZERO_PAGE_X, 2, 6, 0),\n    E(Instruction.SLO, AddressingMode.ZERO_PAGE_X, 2, 6, 0),\n    E(Instruction.CLC, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.ORA, AddressingMode.ABSOLUTE_Y, 3, 4, 1),\n    E(Instruction.NOP, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.SLO, AddressingMode.ABSOLUTE_Y, 3, 7, 0),\n    E(Instruction.NOP, AddressingMode.ABSOLUTE_X, 3, 4, 1),\n    E(Instruction.ORA, AddressingMode.ABSOLUTE_X, 3, 4, 1),\n    E(Instruction.ASL, AddressingMode.ABSOLUTE_X, 3, 7, 0),\n    E(Instruction.SLO, AddressingMode.ABSOLUTE_X, 3, 7, 0),\n    E(Instruction.JSR, AddressingMode.ABSOLUTE, 3, 6, 0),\n    E(Instruction.AND, AddressingMode.X_INDEXED_INDIRECT, 2, 6, 0),\n    undefined,\n    E(Instruction.RLA, AddressingMode.X_INDEXED_INDIRECT, 2, 8, 0),\n    E(Instruction.BIT, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.AND, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.ROL, AddressingMode.ZERO_PAGE, 2, 5, 0),\n    E(Instruction.RLA, AddressingMode.ZERO_PAGE, 2, 5, 0),\n    E(Instruction.PLP, AddressingMode.IMPLICIT, 1, 4, 0),\n    E(Instruction.AND, AddressingMode.IMMEDIATE, 2, 2, 0),\n    E(Instruction.ROL, AddressingMode.ACCUMULATOR, 1, 2, 0),\n    undefined,\n    E(Instruction.BIT, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.AND, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.ROL, AddressingMode.ABSOLUTE, 3, 6, 0),\n    E(Instruction.RLA, AddressingMode.ABSOLUTE, 3, 6, 0),\n    E(Instruction.BMI, AddressingMode.RELATIVE, 2, 2, 1),\n    E(Instruction.AND, AddressingMode.INDIRECT_Y_INDEXED, 2, 5, 1),\n    undefined,\n    E(Instruction.RLA, AddressingMode.INDIRECT_Y_INDEXED, 2, 8, 0),\n    E(Instruction.NOP, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.AND, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.ROL, AddressingMode.ZERO_PAGE_X, 2, 6, 0),\n    E(Instruction.RLA, AddressingMode.ZERO_PAGE_X, 2, 6, 0),\n    E(Instruction.SEC, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.AND, AddressingMode.ABSOLUTE_Y, 3, 4, 1),\n    E(Instruction.NOP, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.RLA, AddressingMode.ABSOLUTE_Y, 3, 7, 0),\n    E(Instruction.NOP, AddressingMode.ABSOLUTE_X, 3, 4, 1),\n    E(Instruction.AND, AddressingMode.ABSOLUTE_X, 3, 4, 1),\n    E(Instruction.ROL, AddressingMode.ABSOLUTE_X, 3, 7, 0),\n    E(Instruction.RLA, AddressingMode.ABSOLUTE_X, 3, 7, 0),\n    E(Instruction.RTI, AddressingMode.IMPLICIT, 1, 6, 0),\n    E(Instruction.EOR, AddressingMode.X_INDEXED_INDIRECT, 2, 6, 0),\n    undefined,\n    E(Instruction.SRE, AddressingMode.X_INDEXED_INDIRECT, 2, 8, 0),\n    E(Instruction.NOP, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.EOR, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.LSR, AddressingMode.ZERO_PAGE, 2, 5, 0),\n    E(Instruction.SRE, AddressingMode.ZERO_PAGE, 2, 5, 0),\n    E(Instruction.PHA, AddressingMode.IMPLICIT, 1, 3, 0),\n    E(Instruction.EOR, AddressingMode.IMMEDIATE, 2, 2, 0),\n    E(Instruction.LSR, AddressingMode.ACCUMULATOR, 1, 2, 0),\n    undefined,\n    E(Instruction.JMP, AddressingMode.ABSOLUTE, 3, 3, 0),\n    E(Instruction.EOR, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.LSR, AddressingMode.ABSOLUTE, 3, 6, 0),\n    E(Instruction.SRE, AddressingMode.ABSOLUTE, 3, 6, 0),\n    E(Instruction.BVC, AddressingMode.RELATIVE, 2, 2, 1),\n    E(Instruction.EOR, AddressingMode.INDIRECT_Y_INDEXED, 2, 5, 1),\n    undefined,\n    E(Instruction.SRE, AddressingMode.INDIRECT_Y_INDEXED, 2, 8, 0),\n    E(Instruction.NOP, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.EOR, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.LSR, AddressingMode.ZERO_PAGE_X, 2, 6, 0),\n    E(Instruction.SRE, AddressingMode.ZERO_PAGE_X, 2, 6, 0),\n    E(Instruction.CLI, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.EOR, AddressingMode.ABSOLUTE_Y, 3, 4, 1),\n    E(Instruction.NOP, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.SRE, AddressingMode.ABSOLUTE_Y, 3, 7, 0),\n    E(Instruction.NOP, AddressingMode.ABSOLUTE_X, 3, 4, 1),\n    E(Instruction.EOR, AddressingMode.ABSOLUTE_X, 3, 4, 1),\n    E(Instruction.LSR, AddressingMode.ABSOLUTE_X, 3, 7, 0),\n    E(Instruction.SRE, AddressingMode.ABSOLUTE_X, 3, 7, 0),\n    E(Instruction.RTS, AddressingMode.IMPLICIT, 1, 6, 0),\n    E(Instruction.ADC, AddressingMode.X_INDEXED_INDIRECT, 2, 6, 0),\n    undefined,\n    E(Instruction.RRA, AddressingMode.X_INDEXED_INDIRECT, 2, 8, 0),\n    E(Instruction.NOP, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.ADC, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.ROR, AddressingMode.ZERO_PAGE, 2, 5, 0),\n    E(Instruction.RRA, AddressingMode.ZERO_PAGE, 2, 5, 0),\n    E(Instruction.PLA, AddressingMode.IMPLICIT, 1, 4, 0),\n    E(Instruction.ADC, AddressingMode.IMMEDIATE, 2, 2, 0),\n    E(Instruction.ROR, AddressingMode.ACCUMULATOR, 1, 2, 0),\n    undefined,\n    E(Instruction.JMP, AddressingMode.INDIRECT, 3, 5, 0),\n    E(Instruction.ADC, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.ROR, AddressingMode.ABSOLUTE, 3, 6, 0),\n    E(Instruction.RRA, AddressingMode.ABSOLUTE, 3, 6, 0),\n    E(Instruction.BVS, AddressingMode.RELATIVE, 2, 2, 1),\n    E(Instruction.ADC, AddressingMode.INDIRECT_Y_INDEXED, 2, 5, 1),\n    undefined,\n    E(Instruction.RRA, AddressingMode.INDIRECT_Y_INDEXED, 2, 8, 0),\n    E(Instruction.NOP, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.ADC, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.ROR, AddressingMode.ZERO_PAGE_X, 2, 6, 0),\n    E(Instruction.RRA, AddressingMode.ZERO_PAGE_X, 2, 6, 0),\n    E(Instruction.SEI, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.ADC, AddressingMode.ABSOLUTE_Y, 3, 4, 1),\n    E(Instruction.NOP, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.RRA, AddressingMode.ABSOLUTE_Y, 3, 7, 0),\n    E(Instruction.NOP, AddressingMode.ABSOLUTE_X, 3, 4, 1),\n    E(Instruction.ADC, AddressingMode.ABSOLUTE_X, 3, 4, 1),\n    E(Instruction.ROR, AddressingMode.ABSOLUTE_X, 3, 7, 0),\n    E(Instruction.RRA, AddressingMode.ABSOLUTE_X, 3, 7, 0),\n    E(Instruction.NOP, AddressingMode.IMMEDIATE, 2, 2, 0),\n    E(Instruction.STA, AddressingMode.X_INDEXED_INDIRECT, 2, 6, 0),\n    E(Instruction.NOP, AddressingMode.IMMEDIATE, 2, 2, 0),\n    E(Instruction.SAX, AddressingMode.X_INDEXED_INDIRECT, 2, 6, 0),\n    E(Instruction.STY, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.STA, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.STX, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.SAX, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.DEY, AddressingMode.IMPLICIT, 1, 2, 0),\n    undefined,\n    E(Instruction.TXA, AddressingMode.IMPLICIT, 1, 2, 0),\n    undefined,\n    E(Instruction.STY, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.STA, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.STX, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.SAX, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.BCC, AddressingMode.RELATIVE, 2, 2, 1),\n    E(Instruction.STA, AddressingMode.INDIRECT_Y_INDEXED, 2, 6, 0),\n    undefined,\n    undefined,\n    E(Instruction.STY, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.STA, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.STX, AddressingMode.ZERO_PAGE_Y, 2, 4, 0),\n    E(Instruction.SAX, AddressingMode.ZERO_PAGE_Y, 2, 4, 0),\n    E(Instruction.TYA, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.STA, AddressingMode.ABSOLUTE_Y, 3, 5, 0),\n    E(Instruction.TXS, AddressingMode.IMPLICIT, 1, 2, 0),\n    undefined,\n    undefined,\n    E(Instruction.STA, AddressingMode.ABSOLUTE_X, 3, 5, 0),\n    undefined,\n    undefined,\n    E(Instruction.LDY, AddressingMode.IMMEDIATE, 2, 2, 0),\n    E(Instruction.LDA, AddressingMode.X_INDEXED_INDIRECT, 2, 6, 0),\n    E(Instruction.LDX, AddressingMode.IMMEDIATE, 2, 2, 0),\n    E(Instruction.LAX, AddressingMode.X_INDEXED_INDIRECT, 2, 6, 0),\n    E(Instruction.LDY, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.LDA, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.LDX, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.LAX, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.TAY, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.LDA, AddressingMode.IMMEDIATE, 2, 2, 0),\n    E(Instruction.TAX, AddressingMode.IMPLICIT, 1, 2, 0),\n    undefined,\n    E(Instruction.LDY, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.LDA, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.LDX, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.LAX, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.BCS, AddressingMode.RELATIVE, 2, 2, 1),\n    E(Instruction.LDA, AddressingMode.INDIRECT_Y_INDEXED, 2, 5, 1),\n    undefined,\n    E(Instruction.LAX, AddressingMode.INDIRECT_Y_INDEXED, 2, 5, 1),\n    E(Instruction.LDY, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.LDA, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.LDX, AddressingMode.ZERO_PAGE_Y, 2, 4, 0),\n    E(Instruction.LAX, AddressingMode.ZERO_PAGE_Y, 2, 4, 0),\n    E(Instruction.CLV, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.LDA, AddressingMode.ABSOLUTE_Y, 3, 4, 1),\n    E(Instruction.TSX, AddressingMode.IMPLICIT, 1, 2, 0),\n    undefined,\n    E(Instruction.LDY, AddressingMode.ABSOLUTE_X, 3, 4, 1),\n    E(Instruction.LDA, AddressingMode.ABSOLUTE_X, 3, 4, 1),\n    E(Instruction.LDX, AddressingMode.ABSOLUTE_Y, 3, 4, 1),\n    E(Instruction.LAX, AddressingMode.ABSOLUTE_Y, 3, 4, 1),\n    E(Instruction.CPY, AddressingMode.IMMEDIATE, 2, 2, 0),\n    E(Instruction.CMP, AddressingMode.X_INDEXED_INDIRECT, 2, 6, 0),\n    undefined,\n    E(Instruction.DCP, AddressingMode.X_INDEXED_INDIRECT, 2, 8, 0),\n    E(Instruction.CPY, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.CMP, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.DEC, AddressingMode.ZERO_PAGE, 2, 5, 0),\n    E(Instruction.DCP, AddressingMode.ZERO_PAGE, 2, 5, 0),\n    E(Instruction.INY, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.CMP, AddressingMode.IMMEDIATE, 2, 2, 0),\n    E(Instruction.DEX, AddressingMode.IMPLICIT, 1, 2, 0),\n    undefined,\n    E(Instruction.CPY, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.CMP, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.DEC, AddressingMode.ABSOLUTE, 3, 6, 0),\n    E(Instruction.DCP, AddressingMode.ABSOLUTE, 3, 6, 0),\n    E(Instruction.BNE, AddressingMode.RELATIVE, 2, 2, 1),\n    E(Instruction.CMP, AddressingMode.INDIRECT_Y_INDEXED, 2, 5, 1),\n    undefined,\n    E(Instruction.DCP, AddressingMode.INDIRECT_Y_INDEXED, 2, 8, 0),\n    E(Instruction.NOP, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.CMP, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.DEC, AddressingMode.ZERO_PAGE_X, 2, 6, 0),\n    E(Instruction.DCP, AddressingMode.ZERO_PAGE_X, 2, 6, 0),\n    E(Instruction.CLD, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.CMP, AddressingMode.ABSOLUTE_Y, 3, 4, 1),\n    E(Instruction.NOP, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.DCP, AddressingMode.ABSOLUTE_Y, 3, 7, 0),\n    E(Instruction.NOP, AddressingMode.ABSOLUTE_X, 3, 4, 1),\n    E(Instruction.CMP, AddressingMode.ABSOLUTE_X, 3, 4, 1),\n    E(Instruction.DEC, AddressingMode.ABSOLUTE_X, 3, 7, 0),\n    E(Instruction.DCP, AddressingMode.ABSOLUTE_X, 3, 7, 0),\n    E(Instruction.CPX, AddressingMode.IMMEDIATE, 2, 2, 0),\n    E(Instruction.SBC, AddressingMode.X_INDEXED_INDIRECT, 2, 6, 0),\n    undefined,\n    E(Instruction.ISC, AddressingMode.X_INDEXED_INDIRECT, 2, 8, 0),\n    E(Instruction.CPX, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.SBC, AddressingMode.ZERO_PAGE, 2, 3, 0),\n    E(Instruction.INC, AddressingMode.ZERO_PAGE, 2, 5, 0),\n    E(Instruction.ISC, AddressingMode.ZERO_PAGE, 2, 5, 0),\n    E(Instruction.INX, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.SBC, AddressingMode.IMMEDIATE, 2, 2, 0),\n    E(Instruction.NOP, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.SBC, AddressingMode.IMMEDIATE, 2, 2, 0),\n    E(Instruction.CPX, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.SBC, AddressingMode.ABSOLUTE, 3, 4, 0),\n    E(Instruction.INC, AddressingMode.ABSOLUTE, 3, 6, 0),\n    E(Instruction.ISC, AddressingMode.ABSOLUTE, 3, 6, 0),\n    E(Instruction.BEQ, AddressingMode.RELATIVE, 2, 2, 1),\n    E(Instruction.SBC, AddressingMode.INDIRECT_Y_INDEXED, 2, 5, 1),\n    undefined,\n    E(Instruction.ISC, AddressingMode.INDIRECT_Y_INDEXED, 2, 8, 0),\n    E(Instruction.NOP, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.SBC, AddressingMode.ZERO_PAGE_X, 2, 4, 0),\n    E(Instruction.INC, AddressingMode.ZERO_PAGE_X, 2, 6, 0),\n    E(Instruction.ISC, AddressingMode.ZERO_PAGE_X, 2, 6, 0),\n    E(Instruction.SED, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.SBC, AddressingMode.ABSOLUTE_Y, 3, 4, 1),\n    E(Instruction.NOP, AddressingMode.IMPLICIT, 1, 2, 0),\n    E(Instruction.ISC, AddressingMode.ABSOLUTE_Y, 3, 7, 0),\n    E(Instruction.NOP, AddressingMode.ABSOLUTE_X, 3, 4, 1),\n    E(Instruction.SBC, AddressingMode.ABSOLUTE_X, 3, 4, 1),\n    E(Instruction.INC, AddressingMode.ABSOLUTE_X, 3, 7, 0),\n    E(Instruction.ISC, AddressingMode.ABSOLUTE_X, 3, 7, 0),\n];\nexports.default = OPCODE_TABLE;\nfunction E(instruction, addressingMode, bytes, cycles, pageCycles) {\n    return {\n        instruction,\n        addressingMode,\n        bytes,\n        cycles,\n        pageCycles,\n    };\n}\n\n\n//# sourceURL=webpack:///./src/cpu/opcode-table.ts?");

/***/ }),

/***/ "./src/cpu/registers.ts":
/*!******************************!*\
  !*** ./src/cpu/registers.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Registers {\n    constructor() {\n        this.PC = 0;\n        this.SP = 0;\n        this.P = 0;\n        this.A = 0;\n        this.X = 0;\n        this.Y = 0;\n    }\n}\nexports.Registers = Registers;\n\n\n//# sourceURL=webpack:///./src/cpu/registers.ts?");

/***/ }),

/***/ "./src/dma/dma.ts":
/*!************************!*\
  !*** ./src/dma/dma.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass DMA {\n    copy(cpuBusAddr) {\n        const data = new Uint8Array(256);\n        for (let i = 0; i < 256; i++) {\n            data[i] = this.cpu.bus.readByte(cpuBusAddr + i);\n        }\n        this.ppu.dmaCopy(data);\n        this.cpu.suspendCycles = this.cpu.cycles & 0x01 ? 513 : 514;\n    }\n}\nexports.DMA = DMA;\n\n\n//# sourceURL=webpack:///./src/dma/dma.ts?");

/***/ }),

/***/ "./src/emulator/emulator.ts":
/*!**********************************!*\
  !*** ./src/emulator/emulator.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cpu_bus_1 = __webpack_require__(/*! ../bus/cpu-bus */ \"./src/bus/cpu-bus.ts\");\nconst cpu_1 = __webpack_require__(/*! ../cpu/cpu */ \"./src/cpu/cpu.ts\");\nconst cartridge_1 = __webpack_require__(/*! ../cartridge/cartridge */ \"./src/cartridge/cartridge.ts\");\nconst ram_1 = __webpack_require__(/*! ../ram/ram */ \"./src/ram/ram.ts\");\nconst ppu_1 = __webpack_require__(/*! ../ppu/ppu */ \"./src/ppu/ppu.ts\");\nconst ppu_bus_1 = __webpack_require__(/*! ../bus/ppu-bus */ \"./src/bus/ppu-bus.ts\");\nconst palettes_1 = __webpack_require__(/*! ./palettes */ \"./src/emulator/palettes.ts\");\nconst dma_1 = __webpack_require__(/*! ../dma/dma */ \"./src/dma/dma.ts\");\nconst standard_controller_1 = __webpack_require__(/*! ../controller/standard-controller */ \"./src/controller/standard-controller.ts\");\nconst interrupt_1 = __webpack_require__(/*! ../interrupt/interrupt */ \"./src/interrupt/interrupt.ts\");\nconst apu_1 = __webpack_require__(/*! ../apu/apu */ \"./src/apu/apu.ts\");\nclass Emulator {\n    constructor(nesData, options) {\n        options = this.parseOptions(options);\n        this.sram = new Uint8Array(8192);\n        this.sram.set(options.sramLoad);\n        const standardController1 = new standard_controller_1.StandardController();\n        const standardController2 = new standard_controller_1.StandardController();\n        const cartridge = new cartridge_1.Cartridge(nesData, this.sram);\n        const ppuRam = new ram_1.RAM(1024 * 2, 0x2000);\n        const cpuRam = new ram_1.RAM(1024 * 2, 0);\n        const backgroundPalette = new ram_1.RAM(16, 0x3F00);\n        const spritePalette = new ram_1.RAM(16, 0x3F10);\n        const dma = new dma_1.DMA();\n        const ppuBus = new ppu_bus_1.PPUBus();\n        const ppu = new ppu_1.PPU(pixels => options.onFrame(this.parsePalettePixels(pixels)));\n        const cpuBus = new cpu_bus_1.CPUBus();\n        const cpu = new cpu_1.CPU();\n        const interrupt = new interrupt_1.Interrupt();\n        const apu = new apu_1.APU(options.sampleRate, options.onSample);\n        cpu.bus = cpuBus;\n        ppu.interrupt = interrupt;\n        ppu.bus = ppuBus;\n        ppu.mapper = cartridge.mapper;\n        apu.cpuBus = cpuBus;\n        apu.interrupt = interrupt;\n        dma.cpu = cpu;\n        dma.ppu = ppu;\n        interrupt.cpu = cpu;\n        ppuBus.cartridge = cartridge;\n        ppuBus.ram = ppuRam;\n        ppuBus.backgroundPallette = backgroundPalette;\n        ppuBus.spritePallette = spritePalette;\n        cpuBus.cartridge = cartridge;\n        cpuBus.ram = cpuRam;\n        cpuBus.ppu = ppu;\n        cpuBus.dma = dma;\n        cpuBus.controller1 = standardController1;\n        cpuBus.controller2 = standardController2;\n        cpuBus.apu = apu;\n        cartridge.mapper.interrupt = interrupt;\n        this.cpu = cpu;\n        this.ppu = ppu;\n        this.cartridge = cartridge;\n        this.ppuRam = ppuRam;\n        this.cpuRam = cpuRam;\n        this.cpuBus = cpuBus;\n        this.ppuBus = ppuBus;\n        this.backgroundPalette = backgroundPalette;\n        this.spritePalette = spritePalette;\n        this.dma = dma;\n        this.standardController1 = standardController1;\n        this.standardController2 = standardController2;\n        this.apu = apu;\n        this.cpu.reset();\n    }\n    clock() {\n        this.cpu.clock();\n        this.apu.clock();\n        this.ppu.clock();\n        this.ppu.clock();\n        this.ppu.clock();\n    }\n    frame() {\n        const frame = this.ppu.frame;\n        while (true) {\n            this.clock();\n            const newFrame = this.ppu.frame;\n            if (newFrame !== frame) {\n                break;\n            }\n        }\n    }\n    parsePalettePixels(pixels) {\n        const arr = new Uint8Array(pixels.length * 3);\n        let ptr = 0;\n        for (const p of pixels) {\n            const color = palettes_1.getColor(p);\n            arr[ptr++] = color[0];\n            arr[ptr++] = color[1];\n            arr[ptr++] = color[2];\n        }\n        return arr;\n    }\n    parseOptions(options) {\n        options = options || {};\n        return {\n            sampleRate: options.sampleRate || 48000,\n            onSample: options.onSample || (() => { }),\n            onFrame: options.onFrame || (() => { }),\n            sramLoad: options.sramLoad || new Uint8Array(8192),\n        };\n    }\n}\nexports.Emulator = Emulator;\n\n\n//# sourceURL=webpack:///./src/emulator/emulator.ts?");

/***/ }),

/***/ "./src/emulator/palettes.ts":
/*!**********************************!*\
  !*** ./src/emulator/palettes.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst TABLE = [\n    0x80, 0x80, 0x80, 0x00, 0x00, 0xBB, 0x37, 0x00, 0xBF, 0x84, 0x00, 0xA6,\n    0xBB, 0x00, 0x6A, 0xB7, 0x00, 0x1E, 0xB3, 0x00, 0x00, 0x91, 0x26, 0x00,\n    0x7B, 0x2B, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x48, 0x0D, 0x00, 0x3C, 0x22,\n    0x00, 0x2F, 0x66, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\n    0xC8, 0xC8, 0xC8, 0x00, 0x59, 0xFF, 0x44, 0x3C, 0xFF, 0xB7, 0x33, 0xCC,\n    0xFF, 0x33, 0xAA, 0xFF, 0x37, 0x5E, 0xFF, 0x37, 0x1A, 0xD5, 0x4B, 0x00,\n    0xC4, 0x62, 0x00, 0x3C, 0x7B, 0x00, 0x1E, 0x84, 0x15, 0x00, 0x95, 0x66,\n    0x00, 0x84, 0xC4, 0x11, 0x11, 0x11, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,\n    0xFF, 0xFF, 0xFF, 0x00, 0x95, 0xFF, 0x6F, 0x84, 0xFF, 0xD5, 0x6F, 0xFF,\n    0xFF, 0x77, 0xCC, 0xFF, 0x6F, 0x99, 0xFF, 0x7B, 0x59, 0xFF, 0x91, 0x5F,\n    0xFF, 0xA2, 0x33, 0xA6, 0xBF, 0x00, 0x51, 0xD9, 0x6A, 0x4D, 0xD5, 0xAE,\n    0x00, 0xD9, 0xFF, 0x66, 0x66, 0x66, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,\n    0xFF, 0xFF, 0xFF, 0x84, 0xBF, 0xFF, 0xBB, 0xBB, 0xFF, 0xD0, 0xBB, 0xFF,\n    0xFF, 0xBF, 0xEA, 0xFF, 0xBF, 0xCC, 0xFF, 0xC4, 0xB7, 0xFF, 0xCC, 0xAE,\n    0xFF, 0xD9, 0xA2, 0xCC, 0xE1, 0x99, 0xAE, 0xEE, 0xB7, 0xAA, 0xF7, 0xEE,\n    0xB3, 0xEE, 0xFF, 0xDD, 0xDD, 0xDD, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11\n];\nfunction getColor(index) {\n    const offset = (index & 0x3F) * 3;\n    return TABLE.slice(offset, offset + 3);\n}\nexports.getColor = getColor;\n\n\n//# sourceURL=webpack:///./src/emulator/palettes.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./emulator/emulator */ \"./src/emulator/emulator.ts\"));\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/interrupt/interrupt.ts":
/*!************************************!*\
  !*** ./src/interrupt/interrupt.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Interrupt {\n    irq() {\n        this.cpu.irq();\n    }\n    nmi() {\n        this.cpu.nmi();\n    }\n}\nexports.Interrupt = Interrupt;\n\n\n//# sourceURL=webpack:///./src/interrupt/interrupt.ts?");

/***/ }),

/***/ "./src/mapper/mapper0.ts":
/*!*******************************!*\
  !*** ./src/mapper/mapper0.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Mapper0 {\n    constructor(cartridge, ram, prg, chr) {\n        this.cartridge = cartridge;\n        this.ram = ram;\n        this.prg = prg;\n        this.chr = chr;\n        this.isMirrored = prg.length === 16 * 1024;\n        if (chr.length === 0) {\n            this.chr = new Uint8Array(0x2000);\n        }\n    }\n    read(address) {\n        address &= 0xFFFF;\n        if (address < 0x2000) {\n            return this.chr[this.parseAddress(address)];\n        }\n        else if (address >= 0x8000) {\n            return this.prg[this.parseAddress(address)];\n        }\n        else if (address >= 0x6000) {\n            return this.ram[address - 0x6000];\n        }\n        else {\n            return 0;\n        }\n    }\n    write(address, data) {\n        address &= 0xFFFF;\n        if (address < 0x2000) {\n            this.chr[this.parseAddress(address)] = data;\n        }\n        else if (address >= 0x8000) {\n            this.prg[this.parseAddress(address)] = data;\n        }\n        else if (address >= 0x6000) {\n            this.ram[address - 0x6000] = data;\n        }\n        else {\n        }\n    }\n    ppuClockHandle(scanLine, cycle) {\n    }\n    parseAddress(address) {\n        if (address < 0x2000) {\n            return address;\n        }\n        else {\n            return (this.isMirrored ? address & 0b1011111111111111 : address) - 0x8000;\n        }\n    }\n}\nexports.Mapper0 = Mapper0;\n\n\n//# sourceURL=webpack:///./src/mapper/mapper0.ts?");

/***/ }),

/***/ "./src/mapper/mapper1.ts":
/*!*******************************!*\
  !*** ./src/mapper/mapper1.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cartridge_1 = __webpack_require__(/*! ../api/cartridge */ \"./src/api/cartridge.ts\");\nclass Mapper1 {\n    constructor(cartridge, ram, prg, chr, prgBanks = prg.length >> 14) {\n        this.cartridge = cartridge;\n        this.ram = ram;\n        this.prg = prg;\n        this.chr = chr;\n        this.prgBanks = prgBanks;\n        this.shiftRegister = 0x10;\n        this.chrBankMode = 0;\n        this.chrBanks = [0, 0];\n        this.prgBankMode = 0;\n        this.prgBank = 0;\n        this.chr = new Uint8Array(128 * 1024);\n        this.chr.set(chr);\n        this.prgBankMode = 3;\n    }\n    read(address) {\n        address &= 0xFFFF;\n        if (address < 0x2000) {\n            return this.readChr(address);\n        }\n        else if (address >= 0x8000) {\n            return this.readPrg(address);\n        }\n        else if (address >= 0x6000) {\n            return this.ram[address - 0x6000];\n        }\n        else {\n            return 0;\n        }\n    }\n    write(address, data) {\n        address &= 0xFFFF;\n        if (address < 0x2000) {\n            this.writeChr(address, data);\n        }\n        else if (address >= 0x8000) {\n            this.loadRegister(address, data);\n        }\n        else if (address >= 0x6000) {\n            this.ram[address - 0x6000] = data;\n        }\n        else {\n        }\n    }\n    ppuClockHandle(scanLine, cycle) {\n    }\n    loadRegister(address, data) {\n        if (data & 0x80) {\n            this.shiftRegister = 0x10;\n            this.prgBankMode = 3;\n        }\n        else {\n            const isOnFifthWrite = !!(this.shiftRegister & 0x01);\n            this.shiftRegister >>= 1;\n            this.shiftRegister |= data & 0x01 ? 0x10 : 0;\n            if (isOnFifthWrite) {\n                this.writeRegister(address, this.shiftRegister);\n                this.shiftRegister = 0x10;\n            }\n        }\n    }\n    writeRegister(address, data) {\n        if (address < 0xA000) {\n            switch (data & 0x03) {\n                case 0:\n                    this.cartridge.info.mirror = cartridge_1.Mirror.SINGLE_SCREEN_LOWER_BANK;\n                    break;\n                case 1:\n                    this.cartridge.info.mirror = cartridge_1.Mirror.SINGLE_SCREEN_UPPER_BANK;\n                    break;\n                case 2:\n                    this.cartridge.info.mirror = cartridge_1.Mirror.VERTICAL;\n                    break;\n                case 3:\n                    this.cartridge.info.mirror = cartridge_1.Mirror.HORIZONTAL;\n                    break;\n            }\n            this.prgBankMode = data >> 2 & 0x03;\n            this.chrBankMode = data >> 4 & 0x01;\n        }\n        else if (address < 0xC000) {\n            this.chrBanks[0] = data & 0x1F;\n        }\n        else if (address < 0xE000) {\n            this.chrBanks[1] = data & 0x1F;\n        }\n        else {\n            this.prgBank = data & 0x0F;\n        }\n    }\n    readChr(address) {\n        return this.chr[this.chrOffset(address)];\n    }\n    writeChr(address, data) {\n        this.chr[this.chrOffset(address)] = data;\n    }\n    readPrg(address) {\n        return this.prg[this.prgOffset(address)];\n    }\n    chrOffset(address) {\n        if (this.chrBankMode) {\n            const bank = address >> 12;\n            const offset = address & 0x0FFF;\n            return (this.chrBanks[bank] << 12) + offset;\n        }\n        else {\n            return ((this.chrBanks[0] & 0x1E) << 12) + address;\n        }\n    }\n    prgOffset(address) {\n        address -= 0x8000;\n        const bank = address >> 14;\n        const offset = address & 0x3FFF;\n        switch (this.prgBankMode) {\n            case 0:\n            case 1:\n                return ((this.prgBank & 0x0E) << 14) + address;\n            case 2:\n                return bank === 0 ? offset : (this.prgBank << 14) + offset;\n            case 3:\n                return bank === 0 ? (this.prgBank << 14) + offset : ((this.prgBanks - 1) << 14) + offset;\n        }\n    }\n}\nexports.Mapper1 = Mapper1;\n\n\n//# sourceURL=webpack:///./src/mapper/mapper1.ts?");

/***/ }),

/***/ "./src/mapper/mapper2.ts":
/*!*******************************!*\
  !*** ./src/mapper/mapper2.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Mapper2 {\n    constructor(cartridge, ram, prg, chr) {\n        this.cartridge = cartridge;\n        this.ram = ram;\n        this.prg = prg;\n        this.chr = chr;\n        this.bankSelect = 0;\n        this.chr = new Uint8Array(8 * 1024);\n        this.chr.set(chr);\n    }\n    read(address) {\n        address &= 0xFFFF;\n        if (address < 0x2000) {\n            return this.chr[address];\n        }\n        else if (address >= 0x8000) {\n            return address < 0xC000 ?\n                this.prg[(this.bankSelect << 14) + address - 0x8000] :\n                this.prg[this.prg.length - 0x4000 + (address - 0xC000)];\n        }\n        else if (address >= 0x6000) {\n            return this.ram[address - 0x6000];\n        }\n        else {\n            return 0;\n        }\n    }\n    write(address, data) {\n        address &= 0xFFFF;\n        if (address < 0x2000) {\n            this.chr[address] = data;\n        }\n        else if (address >= 0x8000) {\n            this.bankSelect = data & 0x0F;\n        }\n        else if (address >= 0x6000) {\n            this.ram[address - 0x6000] = data;\n        }\n        else {\n        }\n    }\n    ppuClockHandle(scanLine, cycle) {\n    }\n}\nexports.Mapper2 = Mapper2;\n\n\n//# sourceURL=webpack:///./src/mapper/mapper2.ts?");

/***/ }),

/***/ "./src/mapper/mapper242.ts":
/*!*********************************!*\
  !*** ./src/mapper/mapper242.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cartridge_1 = __webpack_require__(/*! ../api/cartridge */ \"./src/api/cartridge.ts\");\nclass Mapper242 {\n    constructor(cartridge, ram, prg, chr) {\n        this.cartridge = cartridge;\n        this.ram = ram;\n        this.prg = prg;\n        this.chr = chr;\n        this.prgBankSelect = 0;\n        this.chr = new Uint8Array(0x2000);\n        this.chr.set(chr);\n    }\n    read(address) {\n        address &= 0xFFFF;\n        if (address < 0x2000) {\n            return this.chr[address];\n        }\n        else if (address >= 0x8000) {\n            return this.prg[(this.prgBankSelect << 15) + address - 0x8000];\n        }\n        else if (address >= 0x6000) {\n            return this.ram[address - 0x6000];\n        }\n        else {\n            return 0;\n        }\n    }\n    write(address, data) {\n        address &= 0xFFFF;\n        if (address < 0x2000) {\n            this.chr[address] = data;\n        }\n        else if (address >= 0x8000) {\n            this.cartridge.info.mirror = data & 0x02 ? cartridge_1.Mirror.VERTICAL : cartridge_1.Mirror.HORIZONTAL;\n            this.prgBankSelect = data >> 3 & 0x0F;\n        }\n        else if (address >= 0x6000) {\n            this.ram[address - 0x6000] = data;\n        }\n        else {\n        }\n    }\n    ppuClockHandle(scanLine, cycle) {\n    }\n}\nexports.Mapper242 = Mapper242;\n\n\n//# sourceURL=webpack:///./src/mapper/mapper242.ts?");

/***/ }),

/***/ "./src/mapper/mapper3.ts":
/*!*******************************!*\
  !*** ./src/mapper/mapper3.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Mapper3 {\n    constructor(cartridge, ram, prg, chr) {\n        this.cartridge = cartridge;\n        this.ram = ram;\n        this.prg = prg;\n        this.chr = chr;\n        this.chrBankSelect = 0;\n        this.chr = new Uint8Array(32 * 1024);\n        this.chr.set(chr);\n        this.prg = new Uint8Array(32 * 1024);\n        this.prg.set(prg);\n        if (prg.length === 16 * 1024) {\n            this.prg.set(prg, 16 * 1024);\n        }\n    }\n    read(address) {\n        address &= 0xFFFF;\n        if (address < 0x2000) {\n            return this.chr[(this.chrBankSelect << 13) + address];\n        }\n        else if (address >= 0x8000) {\n            return this.prg[address - 0x8000];\n        }\n        else if (address >= 0x6000) {\n            return this.ram[address - 0x6000];\n        }\n        else {\n            return 0;\n        }\n    }\n    write(address, data) {\n        address &= 0xFFFF;\n        if (address < 0x2000) {\n            this.chr[(this.chrBankSelect << 13) + address] = data;\n        }\n        else if (address >= 0x8000) {\n            this.chrBankSelect = data & 0x03;\n        }\n        else if (address >= 0x6000) {\n            this.ram[address - 0x6000] = data;\n        }\n        else {\n        }\n    }\n    ppuClockHandle(scanLine, cycle) {\n    }\n}\nexports.Mapper3 = Mapper3;\n\n\n//# sourceURL=webpack:///./src/mapper/mapper3.ts?");

/***/ }),

/***/ "./src/mapper/mapper4.ts":
/*!*******************************!*\
  !*** ./src/mapper/mapper4.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cartridge_1 = __webpack_require__(/*! ../api/cartridge */ \"./src/api/cartridge.ts\");\nconst CHR_BANK_TABLE = [\n    [0, 0, 1, 1, 2, 3, 4, 5],\n    [2, 3, 4, 5, 0, 0, 1, 1],\n];\nconst PRG_BANK_TABLE = [\n    [6, 7, -2, -1],\n    [-2, 7, 6, -1],\n];\nclass Mapper4 {\n    constructor(cartridge, ram, prg, chr, prgBanks = prg.length >> 13) {\n        this.cartridge = cartridge;\n        this.ram = ram;\n        this.prg = prg;\n        this.chr = chr;\n        this.prgBanks = prgBanks;\n        this.R = new Uint8Array(8).fill(0);\n        this.register = 0;\n        this.prgBankMode = 0;\n        this.chrA12Inversion = 0;\n        this.isIrqEnable = false;\n        this.irqReloadCounter = 0;\n        this.irqCounter = 0;\n        this.chr = new Uint8Array(256 * 1024);\n        this.chr.set(chr);\n    }\n    read(address) {\n        address &= 0xFFFF;\n        if (address < 0x2000) {\n            return this.readChr(address);\n        }\n        else if (address >= 0x8000) {\n            return this.readPrg(address);\n        }\n        else if (address >= 0x6000) {\n            return this.ram[address - 0x6000];\n        }\n        else {\n            return 0;\n        }\n    }\n    write(address, data) {\n        address &= 0xFFFF;\n        if (address < 0x2000) {\n            this.writeChr(address, data);\n        }\n        else if (address >= 0x8000) {\n            this.writeRegister(address, data);\n        }\n        else if (address >= 0x6000) {\n            this.ram[address - 0x6000] = data;\n        }\n        else {\n        }\n    }\n    ppuClockHandle(scanLine, cycle) {\n        if (cycle !== 260) {\n            return;\n        }\n        if (scanLine > 239 && scanLine < 261) {\n            return;\n        }\n        if (this.irqCounter === 0) {\n            this.irqCounter = this.irqReloadCounter;\n        }\n        else {\n            this.irqCounter--;\n            if (this.irqCounter === 0 && this.isIrqEnable) {\n                this.interrupt.irq();\n            }\n        }\n    }\n    readPrg(address) {\n        return this.prg[this.parsePrgAddress(address)];\n    }\n    readChr(address) {\n        return this.chr[this.parseChrAddress(address)];\n    }\n    writeChr(address, data) {\n        this.chr[this.parseChrAddress(address)] = data;\n    }\n    parsePrgAddress(address) {\n        const cpuBank = (address - 0x8000) >> 13;\n        const offset = address & 0x1FFF;\n        const register = PRG_BANK_TABLE[this.prgBankMode][cpuBank];\n        const bank = register < 0 ? this.prgBanks + register : this.R[register];\n        return ((bank << 13) + offset) % this.prg.length;\n    }\n    parseChrAddress(address) {\n        const ppuBank = address >> 10;\n        const offset = address & 0x03FF;\n        const register = CHR_BANK_TABLE[this.chrA12Inversion][ppuBank];\n        let bank = this.R[register];\n        if ((register === 0 || register === 1) && ppuBank % 2) {\n            bank++;\n        }\n        return ((bank << 10) + offset) % this.chr.length;\n    }\n    writeRegister(address, data) {\n        if (address < 0xA000) {\n            if (address & 0x01) {\n                this.writeBankData(data);\n            }\n            else {\n                this.writeBankSelect(data);\n            }\n        }\n        else if (address < 0xC000) {\n            if (address & 0x01) {\n            }\n            else {\n                if (this.cartridge.info.mirror !== cartridge_1.Mirror.FOUR_SCREEN) {\n                    this.cartridge.info.mirror = data & 0x01 ? cartridge_1.Mirror.HORIZONTAL : cartridge_1.Mirror.VERTICAL;\n                }\n            }\n        }\n        else if (address < 0xE000) {\n            if (address & 0x01) {\n                this.irqCounter = 0;\n            }\n            else {\n                this.irqReloadCounter = data;\n            }\n        }\n        else {\n            if (address & 0x01) {\n                this.isIrqEnable = true;\n            }\n            else {\n                this.isIrqEnable = false;\n            }\n        }\n    }\n    writeBankSelect(data) {\n        this.register = data & 0x07;\n        this.prgBankMode = data & 0x40 ? 1 : 0;\n        this.chrA12Inversion = data & 0x80 ? 1 : 0;\n    }\n    writeBankData(data) {\n        if (this.register === 6 || this.register === 7) {\n            data &= 0x3F;\n        }\n        else if (this.register === 0 || this.register === 1) {\n            data &= 0xFE;\n        }\n        this.R[this.register] = data;\n    }\n}\nexports.Mapper4 = Mapper4;\n\n\n//# sourceURL=webpack:///./src/mapper/mapper4.ts?");

/***/ }),

/***/ "./src/mapper/mapper74.ts":
/*!********************************!*\
  !*** ./src/mapper/mapper74.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mapper4_1 = __webpack_require__(/*! ./mapper4 */ \"./src/mapper/mapper4.ts\");\nclass Mapper74 extends mapper4_1.Mapper4 {\n}\nexports.Mapper74 = Mapper74;\n\n\n//# sourceURL=webpack:///./src/mapper/mapper74.ts?");

/***/ }),

/***/ "./src/ppu/controller.ts":
/*!*******************************!*\
  !*** ./src/ppu/controller.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ppu_1 = __webpack_require__(/*! ../api/ppu */ \"./src/api/ppu.ts\");\nconst BaseNameTableAddressList = [0x2000, 0x2400, 0x2800, 0x2C00];\nclass Controller {\n    constructor() {\n        this.baseNameTableAddress = BaseNameTableAddressList[0];\n        this.vramIncrementStepSize = 1;\n        this.spritePatternTableAddress = 0;\n        this.backgroundPatternTableAddress = 0;\n        this.spriteSize = ppu_1.SpriteSize.SIZE_8X8;\n        this.isNMIEnabled = false;\n    }\n    set data(data) {\n        this.baseNameTableAddress = BaseNameTableAddressList[data & 0x03];\n        this.vramIncrementStepSize = data & 0x04 ? 32 : 1;\n        this.spritePatternTableAddress = data & 0x08 ? 0x1000 : 0;\n        this.backgroundPatternTableAddress = data & 0x10 ? 0x1000 : 0;\n        this.spriteSize = data & 0x20 ? ppu_1.SpriteSize.SIZE_8X16 : ppu_1.SpriteSize.SIZE_8X8;\n        this.isNMIEnabled = !!(data & 0x80);\n    }\n    get data() {\n        return BaseNameTableAddressList.indexOf(this.baseNameTableAddress) |\n            (this.vramIncrementStepSize === 1 ? 0 : 1) << 2 |\n            (this.spritePatternTableAddress ? 1 : 0) << 3 |\n            (this.backgroundPatternTableAddress ? 1 : 0) << 4 |\n            (this.spriteSize === ppu_1.SpriteSize.SIZE_8X8 ? 0 : 1) << 5 |\n            (this.isNMIEnabled ? 1 : 0) << 7;\n    }\n}\nexports.Controller = Controller;\n\n\n//# sourceURL=webpack:///./src/ppu/controller.ts?");

/***/ }),

/***/ "./src/ppu/mask.ts":
/*!*************************!*\
  !*** ./src/ppu/mask.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Mask {\n    set data(data) {\n        this.isColorful = !(data & 0x01);\n        this.isShowBackgroundLeft8px = !!(data & 0x02);\n        this.isShowSpriteLeft8px = !!(data & 0x04);\n        this.isShowBackground = !!(data & 0x08);\n        this.isShowSprite = !!(data & 0x10);\n        this.isEmphasizeRed = !!(data & 0x20);\n        this.isEmphasizeGreen = !!(data & 0x40);\n        this.isEmphasizeBlue = !!(data & 0x80);\n    }\n    get data() {\n        return (this.isColorful ? 0 : 1) |\n            (this.isShowBackgroundLeft8px ? 1 : 0) << 1 |\n            (this.isShowSpriteLeft8px ? 1 : 0) << 2 |\n            (this.isShowBackground ? 1 : 0) << 3 |\n            (this.isShowSprite ? 1 : 0) << 4 |\n            (this.isEmphasizeRed ? 1 : 0) << 5 |\n            (this.isEmphasizeGreen ? 1 : 0) << 6 |\n            (this.isEmphasizeBlue ? 1 : 0) << 7;\n    }\n}\nexports.Mask = Mask;\n\n\n//# sourceURL=webpack:///./src/ppu/mask.ts?");

/***/ }),

/***/ "./src/ppu/ppu.ts":
/*!************************!*\
  !*** ./src/ppu/ppu.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ppu_1 = __webpack_require__(/*! ../api/ppu */ \"./src/api/ppu.ts\");\nconst controller_1 = __webpack_require__(/*! ./controller */ \"./src/ppu/controller.ts\");\nconst mask_1 = __webpack_require__(/*! ./mask */ \"./src/ppu/mask.ts\");\nconst status_1 = __webpack_require__(/*! ./status */ \"./src/ppu/status.ts\");\nvar Register;\n(function (Register) {\n    Register[Register[\"PPUCTRL\"] = 8192] = \"PPUCTRL\";\n    Register[Register[\"PPUMASK\"] = 8193] = \"PPUMASK\";\n    Register[Register[\"PPUSTATUS\"] = 8194] = \"PPUSTATUS\";\n    Register[Register[\"OAMADDR\"] = 8195] = \"OAMADDR\";\n    Register[Register[\"OAMDATA\"] = 8196] = \"OAMDATA\";\n    Register[Register[\"PPUSCROLL\"] = 8197] = \"PPUSCROLL\";\n    Register[Register[\"PPUADDR\"] = 8198] = \"PPUADDR\";\n    Register[Register[\"PPUDATA\"] = 8199] = \"PPUDATA\";\n})(Register || (Register = {}));\nvar SpriteAttribute;\n(function (SpriteAttribute) {\n    SpriteAttribute[SpriteAttribute[\"PALETTE_L\"] = 1] = \"PALETTE_L\";\n    SpriteAttribute[SpriteAttribute[\"PALETTE_H\"] = 2] = \"PALETTE_H\";\n    SpriteAttribute[SpriteAttribute[\"PRIORITY\"] = 32] = \"PRIORITY\";\n    SpriteAttribute[SpriteAttribute[\"FLIP_H\"] = 64] = \"FLIP_H\";\n    SpriteAttribute[SpriteAttribute[\"FLIP_V\"] = 128] = \"FLIP_V\";\n})(SpriteAttribute || (SpriteAttribute = {}));\nvar SpritePixel;\n(function (SpritePixel) {\n    SpritePixel[SpritePixel[\"PALETTE\"] = 63] = \"PALETTE\";\n    SpritePixel[SpritePixel[\"BEHIND_BG\"] = 64] = \"BEHIND_BG\";\n    SpritePixel[SpritePixel[\"ZERO\"] = 128] = \"ZERO\";\n})(SpritePixel || (SpritePixel = {}));\nclass PPU {\n    constructor(onFrame) {\n        this.onFrame = onFrame;\n        this.pixels = new Uint8Array(256 * 240);\n        this.oamMemory = new Uint8Array(256);\n        this.controller = new controller_1.Controller();\n        this.mask = new mask_1.Mask();\n        this.register = { v: 0, t: 0, x: 0, w: 0 };\n        this.shiftRegister = {};\n        this.latchs = {};\n        this.status = new status_1.Status();\n        this.nmiDelay = 0;\n        this.readBuffer = 0;\n        this.frame = 0;\n        this.scanLine = 240;\n        this.cycle = 340;\n        this.secondaryOam = Array(8).fill(0).map(() => Object.create(null));\n        this.spritePixels = new Array(256);\n        this.previousData = 0;\n    }\n    clock() {\n        if (this.scanLine === 261 && this.cycle === 339 && this.frame & 0x01 && (this.mask.isShowBackground || this.mask.isShowSprite)) {\n            this.updateCycle();\n        }\n        this.updateCycle();\n        if (!this.mask.isShowBackground && !this.mask.isShowSprite) {\n            return;\n        }\n        if (0 <= this.scanLine && this.scanLine <= 239) {\n            if (1 === this.cycle) {\n                this.clearSecondaryOam();\n            }\n            if (65 === this.cycle) {\n                this.evalSprite();\n            }\n            if (1 <= this.cycle && this.cycle <= 256) {\n                this.shiftBackground();\n                this.renderPixel();\n                this.fetchTileRelatedData();\n            }\n            if (this.cycle === 256) {\n                this.incrementVerticalPosition();\n            }\n            if (this.cycle === 257) {\n                this.copyHorizontalBits();\n            }\n            if (this.cycle === 257) {\n                this.fetchSprite();\n            }\n            if (321 <= this.cycle && this.cycle <= 336) {\n                this.shiftBackground();\n                this.fetchTileRelatedData();\n            }\n        }\n        if (this.scanLine === 261) {\n            if (1 <= this.cycle && this.cycle <= 256) {\n                this.shiftBackground();\n                this.fetchTileRelatedData();\n            }\n            if (this.cycle === 256) {\n                this.incrementVerticalPosition();\n            }\n            if (this.cycle === 257) {\n                this.copyHorizontalBits();\n            }\n            if (this.cycle === 280) {\n                this.copyVerticalBits();\n            }\n            if (321 <= this.cycle && this.cycle <= 336) {\n                this.shiftBackground();\n                this.fetchTileRelatedData();\n            }\n        }\n    }\n    cpuRead(address) {\n        switch (address) {\n            case Register.PPUCTRL:\n                return this.readCtrl();\n            case Register.PPUMASK:\n                return this.readMask();\n            case Register.PPUSTATUS:\n                return this.readStatus();\n            case Register.OAMADDR:\n                return 0;\n            case Register.OAMDATA:\n                return this.readOAMData();\n            case Register.PPUSCROLL:\n                return 0;\n            case Register.PPUADDR:\n                return 0;\n            case Register.PPUDATA:\n                return this.readPPUData();\n        }\n    }\n    cpuWrite(address, data) {\n        data &= 0xFF;\n        this.previousData = data & 0x1F;\n        switch (address) {\n            case Register.PPUCTRL:\n                this.writeCtrl(data);\n                break;\n            case Register.PPUMASK:\n                this.writeMask(data);\n                break;\n            case Register.PPUSTATUS:\n                break;\n            case Register.OAMADDR:\n                this.writeOAMAddr(data);\n                break;\n            case Register.OAMDATA:\n                this.writeOAMData(data);\n                break;\n            case Register.PPUSCROLL:\n                this.writeScroll(data);\n                break;\n            case Register.PPUADDR:\n                this.writePPUAddr(data);\n                break;\n            case Register.PPUDATA:\n                this.writePPUData(data);\n                break;\n        }\n    }\n    dmaCopy(data) {\n        for (let i = 0; i < 256; i++) {\n            this.oamMemory[(i + this.oamAddress) & 0xFF] = data[i];\n        }\n    }\n    writeCtrl(data) {\n        this.controller.data = data;\n        this.register.t = this.register.t & 0xF3FF | (data & 0x03) << 10;\n    }\n    readCtrl() {\n        return this.controller.data;\n    }\n    writeMask(data) {\n        this.mask.data = data;\n    }\n    readMask() {\n        return this.mask.data;\n    }\n    readStatus() {\n        const data = this.status.data | this.previousData;\n        this.status.isVBlankStarted = false;\n        this.register.w = 0;\n        return data;\n    }\n    writeOAMAddr(data) {\n        this.oamAddress = data;\n    }\n    readOAMData() {\n        return this.oamMemory[this.oamAddress];\n    }\n    writeOAMData(data) {\n        this.oamMemory[this.oamAddress++ & 0xFF] = data;\n    }\n    writeScroll(data) {\n        if (this.register.w === 0) {\n            this.register.t = this.register.t & 0xFFE0 | data >> 3;\n            this.register.x = data & 0x07;\n            this.register.w = 1;\n        }\n        else {\n            this.register.t = this.register.t & 0x0C1F | (data & 0x07) << 12 | (data & 0xF8) << 2;\n            this.register.w = 0;\n        }\n    }\n    writePPUAddr(data) {\n        if (this.register.w === 0) {\n            this.register.t = this.register.t & 0x80FF | (data & 0x3F) << 8;\n            this.register.w = 1;\n        }\n        else {\n            this.register.t = this.register.t & 0xFF00 | data;\n            this.register.v = this.register.t;\n            this.register.w = 0;\n        }\n    }\n    readPPUData() {\n        let data = this.bus.readByte(this.register.v);\n        if (this.register.v <= 0x3EFF) {\n            const tmp = this.readBuffer;\n            this.readBuffer = data;\n            data = tmp;\n        }\n        else {\n            this.readBuffer = this.bus.readByte(this.register.v - 0x1000);\n        }\n        this.register.v += this.controller.vramIncrementStepSize;\n        this.register.v &= 0x7FFF;\n        return data;\n    }\n    writePPUData(data) {\n        this.bus.writeByte(this.register.v, data);\n        this.register.v += this.controller.vramIncrementStepSize;\n    }\n    updateCycle() {\n        if (this.status.isVBlankStarted && this.controller.isNMIEnabled && this.nmiDelay-- === 0) {\n            this.interrupt.nmi();\n        }\n        this.cycle++;\n        if (this.cycle > 340) {\n            this.cycle = 0;\n            this.scanLine++;\n            if (this.scanLine > 261) {\n                this.scanLine = 0;\n                this.frame++;\n                this.onFrame(this.pixels);\n            }\n        }\n        if (this.scanLine === 241 && this.cycle === 1) {\n            this.status.isVBlankStarted = true;\n            if (this.controller.isNMIEnabled) {\n                this.nmiDelay = 15;\n            }\n        }\n        if (this.scanLine === 261 && this.cycle === 1) {\n            this.status.isVBlankStarted = false;\n            this.status.isZeroSpriteHit = false;\n            this.status.isSpriteOverflow = false;\n        }\n        if (this.mask.isShowBackground || this.mask.isShowSprite) {\n            this.mapper.ppuClockHandle(this.scanLine, this.cycle);\n        }\n    }\n    fetchTileRelatedData() {\n        if (!this.mask.isShowBackground) {\n            return;\n        }\n        switch (this.cycle % 8) {\n            case 1:\n                this.loadBackground();\n                this.fetchNameTable();\n                break;\n            case 3:\n                this.fetchAttributeTable();\n                break;\n            case 5:\n                this.fetchLowBackgroundTileByte();\n                break;\n            case 7:\n                this.fetchHighBackgroundTileByte();\n                break;\n            case 0:\n                this.incrementHorizontalPosition();\n                break;\n        }\n    }\n    fetchNameTable() {\n        const address = 0x2000 | (this.register.v & 0x0FFF);\n        this.latchs.nameTable = this.bus.readByte(address);\n    }\n    fetchAttributeTable() {\n        const address = 0x23C0 |\n            (this.register.v & 0x0C00) |\n            ((this.register.v >> 4) & 0x38) |\n            ((this.register.v >> 2) & 0x07);\n        const isRight = !!(this.register.v & 0x02);\n        const isBottom = !!(this.register.v & 0x40);\n        const offset = (isBottom ? 0x02 : 0) | (isRight ? 0x01 : 0);\n        this.latchs.attributeTable = this.bus.readByte(address) >> (offset << 1) & 0x03;\n    }\n    fetchLowBackgroundTileByte() {\n        const address = this.controller.backgroundPatternTableAddress +\n            this.latchs.nameTable * 16 +\n            (this.register.v >> 12 & 0x07);\n        this.latchs.lowBackgorundTailByte = this.bus.readByte(address);\n    }\n    fetchHighBackgroundTileByte() {\n        const address = this.controller.backgroundPatternTableAddress +\n            this.latchs.nameTable * 16 +\n            (this.register.v >> 12 & 0x07) + 8;\n        this.latchs.highBackgorundTailByte = this.bus.readByte(address);\n    }\n    loadBackground() {\n        this.shiftRegister.lowBackgorundTailBytes |= this.latchs.lowBackgorundTailByte;\n        this.shiftRegister.highBackgorundTailBytes |= this.latchs.highBackgorundTailByte;\n        this.shiftRegister.lowBackgroundAttributeByes |= (this.latchs.attributeTable & 0x01) ? 0xFF : 0;\n        this.shiftRegister.highBackgroundAttributeByes |= (this.latchs.attributeTable & 0x02) ? 0xFF : 0;\n    }\n    shiftBackground() {\n        if (!this.mask.isShowBackground) {\n            return;\n        }\n        this.shiftRegister.lowBackgorundTailBytes <<= 1;\n        this.shiftRegister.highBackgorundTailBytes <<= 1;\n        this.shiftRegister.lowBackgroundAttributeByes <<= 1;\n        this.shiftRegister.highBackgroundAttributeByes <<= 1;\n    }\n    incrementHorizontalPosition() {\n        if ((this.register.v & 0x001F) === 31) {\n            this.register.v &= ~0x001F;\n            this.register.v ^= 0x0400;\n        }\n        else {\n            this.register.v += 1;\n        }\n    }\n    incrementVerticalPosition() {\n        if ((this.register.v & 0x7000) !== 0x7000) {\n            this.register.v += 0x1000;\n        }\n        else {\n            this.register.v &= ~0x7000;\n            let y = (this.register.v & 0x03E0) >> 5;\n            if (y === 29) {\n                y = 0;\n                this.register.v ^= 0x0800;\n            }\n            else if (y === 31) {\n                y = 0;\n            }\n            else {\n                y += 1;\n            }\n            this.register.v = (this.register.v & ~0x03E0) | (y << 5);\n        }\n    }\n    copyHorizontalBits() {\n        this.register.v = (this.register.v & 0b1111101111100000) | (this.register.t & ~0b1111101111100000) & 0x7FFF;\n    }\n    copyVerticalBits() {\n        this.register.v = (this.register.v & 0b1000010000011111) | (this.register.t & ~0b1000010000011111) & 0x7FFF;\n    }\n    renderPixel() {\n        const x = this.cycle - 1;\n        const y = this.scanLine;\n        const offset = 0x8000 >> this.register.x;\n        const bit0 = this.shiftRegister.lowBackgorundTailBytes & offset ? 1 : 0;\n        const bit1 = this.shiftRegister.highBackgorundTailBytes & offset ? 1 : 0;\n        const bit2 = this.shiftRegister.lowBackgroundAttributeByes & offset ? 1 : 0;\n        const bit3 = this.shiftRegister.highBackgroundAttributeByes & offset ? 1 : 0;\n        const paletteIndex = bit3 << 3 | bit2 << 2 | bit1 << 1 | bit0 << 0;\n        const spritePaletteIndex = this.spritePixels[x] & SpritePixel.PALETTE;\n        const isTransparentSprite = spritePaletteIndex % 4 === 0 || !this.mask.isShowSprite;\n        const isTransparentBackground = paletteIndex % 4 === 0 || !this.mask.isShowBackground;\n        let address = 0x3F00;\n        if (isTransparentBackground) {\n            if (isTransparentSprite) {\n            }\n            else {\n                address = 0x3F10 + spritePaletteIndex;\n            }\n        }\n        else {\n            if (isTransparentSprite) {\n                address = 0x3F00 + paletteIndex;\n            }\n            else {\n                if (this.spritePixels[x] & SpritePixel.ZERO) {\n                    if ((!this.mask.isShowBackground || !this.mask.isShowSprite) ||\n                        (0 <= x && x <= 7 && (!this.mask.isShowSpriteLeft8px || !this.mask.isShowBackgroundLeft8px)) ||\n                        x === 255) {\n                    }\n                    else {\n                        this.status.isZeroSpriteHit = true;\n                    }\n                }\n                address = this.spritePixels[x] & SpritePixel.BEHIND_BG ? 0x3F00 + paletteIndex : 0x3F10 + spritePaletteIndex;\n            }\n        }\n        this.pixels[x + y * 256] = this.bus.readByte(address);\n    }\n    clearSecondaryOam() {\n        if (!this.mask.isShowSprite) {\n            return;\n        }\n        this.secondaryOam.forEach(oam => {\n            oam.attributes = 0xFF;\n            oam.tileIndex = 0xFF;\n            oam.x = 0xFF;\n            oam.y = 0xFF;\n        });\n    }\n    evalSprite() {\n        if (!this.mask.isShowSprite) {\n            return;\n        }\n        let spriteCount = 0;\n        for (let i = 0; i < 64; i++) {\n            const y = this.oamMemory[i * 4];\n            if (this.scanLine < y || (this.scanLine >= y + this.controller.spriteSize)) {\n                continue;\n            }\n            if (spriteCount === 8) {\n                this.status.isSpriteOverflow = true;\n                break;\n            }\n            const oam = this.secondaryOam[spriteCount++];\n            oam.y = y;\n            oam.tileIndex = this.oamMemory[i * 4 + 1];\n            oam.attributes = this.oamMemory[i * 4 + 2];\n            oam.x = this.oamMemory[i * 4 + 3];\n            oam.isZero = i === 0;\n        }\n    }\n    fetchSprite() {\n        if (!this.mask.isShowSprite) {\n            return;\n        }\n        this.spritePixels.fill(0);\n        for (const sprite of this.secondaryOam.reverse()) {\n            if (sprite.y >= 0xEF) {\n                continue;\n            }\n            const isBehind = !!(sprite.attributes & SpriteAttribute.PRIORITY);\n            const isZero = sprite.isZero;\n            const isFlipH = !!(sprite.attributes & SpriteAttribute.FLIP_H);\n            const isFlipV = !!(sprite.attributes & SpriteAttribute.FLIP_V);\n            let address;\n            if (this.controller.spriteSize === ppu_1.SpriteSize.SIZE_8X8) {\n                const baseAddress = this.controller.spritePatternTableAddress + (sprite.tileIndex << 4);\n                const offset = isFlipV ? (7 - this.scanLine + sprite.y) : (this.scanLine - sprite.y);\n                address = baseAddress + offset;\n            }\n            else {\n                const baseAddress = ((sprite.tileIndex & 0x01) ? 0x1000 : 0x0000) + ((sprite.tileIndex & 0xFE) << 4);\n                const offset = isFlipV ? (15 - this.scanLine + sprite.y) : (this.scanLine - sprite.y);\n                address = baseAddress + offset % 8 + Math.floor(offset / 8) * 16;\n            }\n            const tileL = this.bus.readByte(address);\n            const tileH = this.bus.readByte(address + 8);\n            for (let i = 0; i < 8; i++) {\n                const b = isFlipH ? 0x01 << i : 0x80 >> i;\n                const bit0 = tileL & b ? 1 : 0;\n                const bit1 = tileH & b ? 1 : 0;\n                const bit2 = sprite.attributes & SpriteAttribute.PALETTE_L ? 1 : 0;\n                const bit3 = sprite.attributes & SpriteAttribute.PALETTE_H ? 1 : 0;\n                const index = bit3 << 3 | bit2 << 2 | bit1 << 1 | bit0;\n                if (index % 4 === 0 && (this.spritePixels[sprite.x + i] & SpritePixel.PALETTE) % 4 !== 0) {\n                    continue;\n                }\n                this.spritePixels[sprite.x + i] = index |\n                    (isBehind ? SpritePixel.BEHIND_BG : 0) |\n                    (isZero ? SpritePixel.ZERO : 0);\n            }\n        }\n    }\n}\nexports.PPU = PPU;\n\n\n//# sourceURL=webpack:///./src/ppu/ppu.ts?");

/***/ }),

/***/ "./src/ppu/status.ts":
/*!***************************!*\
  !*** ./src/ppu/status.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Status {\n    get data() {\n        return (this.isSpriteOverflow ? 0x20 : 0) |\n            (this.isZeroSpriteHit ? 0x40 : 0) |\n            (this.isVBlankStarted ? 0x80 : 0);\n    }\n}\nexports.Status = Status;\n\n\n//# sourceURL=webpack:///./src/ppu/status.ts?");

/***/ }),

/***/ "./src/ram/ram.ts":
/*!************************!*\
  !*** ./src/ram/ram.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass RAM {\n    constructor(size, offset = 0) {\n        this.offset = offset;\n        this.ram = new Uint8Array(size);\n    }\n    read(address) {\n        address = (address - this.offset) & 0xFFFF;\n        return this.ram[address];\n    }\n    write(address, data) {\n        address = (address - this.offset) & 0xFFFF;\n        this.ram[address] = data;\n    }\n}\nexports.RAM = RAM;\n\n\n//# sourceURL=webpack:///./src/ram/ram.ts?");

/***/ })

/******/ });